<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">


<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<rfc  xmlns:xi="http://www.w3.org/2001/XInclude" category="std" ipr='trust200902' tocInclude="true" indexInclude="true" obsoletes=""  consensus="true" submissionType="IETF" xml:lang="en" version="3" docName="draft-ietf-roll-dao-projection-latest" >

<front>

   <title abbrev='DAO Projection'>Root initiated routing state in RPL</title>
   <author initials='P' surname='Thubert' fullname='Pascal Thubert' role='editor'>
      <organization abbrev='Cisco Systems'>Cisco Systems, Inc</organization>
      <address>
         <postal>
            <street>Building D</street>
            <street>45 Allee des Ormes - BP1200 </street>
            <city>Mougins - Sophia Antipolis</city>
            <code>06254</code>
          <country>France</country>
         </postal>
         <phone>+33 497 23 26 34</phone>
         <email>pthubert@cisco.com</email>
      </address>
   </author>

    <author fullname="Rahul Arvind Jadhav" initials="R.A." surname="Jadhav">
        <organization>Huawei Tech</organization>
        <address>
            <postal>
                <street>Kundalahalli Village, Whitefield,</street>
                <city>Bangalore</city>
                <region>Karnataka</region>
                <code>560037</code>
                <country>India</country>
            </postal>
            <phone>+91-080-49160700</phone>
            <email>rahul.ietf@gmail.com</email>
        </address>
    </author>

<!--
<author initials='M' surname='Gillmore' fullname='Matthew Gillmore'>
      <organization abbrev='Itron'>Itron, Inc</organization>
      <address>
         <postal>
            <street>Building D</street>
            <street>2111 N Molter Road</street>
            <city>Liberty Lake</city>
            <code>99019</code>
            <country>United States</country>
         </postal>
         <phone>+1.800.635.5461</phone>
         <email>matthew.gillmore@itron.com</email>
      </address>
   </author>
-->
        <date/>

	<area>Routing</area>

	<workgroup>ROLL</workgroup>

        <abstract>
	  <t>
     This document extends RFC 6550, RFC 6553, and RFC 8138 to enable a RPL Root
     to install and maintain Projected Routes within its DODAG, along a selected
     set of nodes that may or may not include self, for a chosen duration.
     This potentially enables routes
    that are more optimized or resilient than those obtained with the
    classical distributed operation of RPL, either in terms of the size of a
    Routing Header or in terms of path length, which impacts both the
    latency and the packet delivery ratio.
	  </t>
	</abstract>
    </front>

    <middle>

	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<section anchor='introduction'><name>Introduction</name>

	   <t> RPL, the <xref target='RFC6550'>
   "Routing Protocol for Low Power and Lossy Networks"</xref> (LLNs),
   is an anisotropic Distance Vector protocol that is well-suited
   for application in a variety of low energy Internet of Things (IoT)
   networks where stretched P2P paths are acceptable vs. the signaling
   and state overhead involved in maintaining shortest paths across.
    </t>
<t>
   RPL forms destination Oriented Directed Acyclic Graphs (DODAGs) in which
   the Root often acts as the Border router to connect the RPL domain to the
   IP backbone and routes along that graph up, towards the Root, and down
   towards the nodes.
    </t>
<t>
   With this specification, an abstract routing function called a Path
   Computation Element <xref target='PCE'/> (e.g., located in an central
   controller or collocated with the Root) interacts with the RPL Root to
   compute Peer to Peer (P2P) paths within a pre-existing RPL Main DODAG.
   The topological information that is passed to the PCE is derived from the
   DODAG that is already available at the Root in RPL Non-Storing Mode. This
   specification introduces protocol extensions that enrich the topological
   information that is available at the Root and passed to the PCE.
    </t>
<t>
   Based on usage, path length, and knowledge of available resources such as
   battery levels and reservable buffers in the nodes, the PCE with a global
   visibility on the system can optimize the computed routes for the
   application needs, including the capability to provide path redundancy.
   This specification also introduces protocol extensions that enable the
   Root to translates the computed paths into RPL and install them as
   Projected Routes (aka P-Routes) inside the DODAG on behalf of a PCE.
   </t>
    </section>

	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->

<section><name>Terminology</name>
<section anchor='bcp'><name>Requirements Language</name>
<t>

    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in BCP 14
    <xref target='RFC2119'/><xref target='RFC8174'/> when, and only when, they
    appear in all capitals, as shown here.

</t>

<t>
  In addition, the terms "Extends" and "Amends" are used as per
  <xref target="I-D.kuehlewind-update-tag" /> section 3.
</t>

</section>	<!-- end section "Requirements Language" -->

  <section anchor='lo'><name>References</name>
    <t>
	In this document, readers will encounter terms and concepts
	that are discussed in the <xref target='RFC6550'>"Routing Protocol for Low Power and Lossy Networks"</xref>, the <xref target='RFC9030'> "6TiSCH Architecture"</xref>, the <xref target='RFC8655'>
    "Deterministic Networking Architecture"</xref>, the <xref target='I-D.ietf-raw-architecture'>"Reliable and
    Available Wireless (RAW) Architecture"</xref>,
    and
    <xref target='RFC7102'>"Terminology in Low power And Lossy Networks"</xref>.
    </t>
  </section>	<!-- end section "References" -->



<section anchor='gloss'><name>Glossary</name>
    <t> This document often uses the following acronyms:
       </t><dl spacing='compact'>
       <dt>CMO:</dt><dd> Control Message Option</dd>
       <dt>DAO:</dt><dd> destination Advertisement Object</dd>
       <dt>DAG:</dt><dd> Directed Acyclic Graph </dd>
       <dt>DODAG:</dt><dd> destination-Oriented Directed Acyclic Graph; A DAG
       with only one vertex (i.e., node) that has no outgoing edge (i.e., link)
       </dd>
       <dt>GUA:</dt><dd> IPv6 Global Unicast Address</dd>
       <dt>LLN:</dt><dd> Low-Power and Lossy Network </dd>
       <dt>MOP:</dt><dd> RPL Mode of Operation</dd>
       <dt>P-DAO:</dt><dd> Projected DAO </dd>
       <dt>P-Route:</dt><dd> Projected Route </dd>
       <dt>PDR:</dt><dd> P-DAO Request </dd>
       <dt>RAN:</dt><dd> RPL-Aware Node (either a RPL router or a RPL-Aware Leaf)</dd>
       <dt>RAL:</dt><dd> RPL-Aware Leaf </dd>
       <dt>RH:</dt><dd> Routing Header </dd>
       <dt>RPI:</dt><dd> RPL Packet Information </dd>
       <dt>RTO:</dt><dd> RPL Target Option</dd>
       <dt>RUL:</dt><dd> RPL-Unaware Leaf </dd>
       <dt>SIO:</dt><dd> RPL Sibling Information Option</dd>
       <dt>ULA:</dt><dd> IPv6 Unique Local Address</dd>
       <dt>NSM-VIO:</dt><dd> A Source-Routed Via Information Option, used in Non-Storing Mode P-DAO messages.    </dd>
       <!--
       <dt>SubDAG:</dt><dd> A DODAG Rooted at a node which is a child of that
       node and a subset of a larger DAG</dd> -->
       <dt>SLO:</dt><dd> Service Level Objective </dd>
       <dt>TIO:</dt><dd> RPL Transit Information Option</dd>
       <dt>SM-VIO:</dt><dd> A strict Via Information Option, used in Storing Mode P-DAO messages.    </dd>
       <dt>VIO:</dt><dd> A Via Information Option; it can be a SM-VIO or an NSM-VIO.    </dd>
       </dl>

</section>	<!-- Glossary -->



<section anchor='new'><name>Domain Terms</name>
    <t>
    <!-- Removed reference from routing and 6tisch here to keep it simple -->
	 This specification uses the following terminology:
    </t>
  <section><name>Projected Route</name><t>
	A RPL P-Route is a RPL route that is computed remotely by a PCE, and installed and maintained by a RPL Root on behalf of the PCE. It
    is installed as a state that signals that destinations (aka Targets)
    are reachable along a sequence of nodes.</t>

  </section>
  <section><name>Projected DAO</name>
    <t> A DAO message used to install a P-Route. </t>
  </section>
  <section><name>Path</name>
    <t>Quoting section 1.1.3 of <xref target="RFC1122"/>:</t>
    <blockquote>
    At a given moment, all the IP datagrams from a particular source host to a
    particular destination host will typically traverse the same sequence of
    gateways.  We use the term "path" for this sequence.  Note that a path is
    uni-directional; it is not unusual to have different paths in the two
    directions between a given host pair.
    </blockquote>
    <t>
    Section 2 of <xref target="I-D.irtf-panrg-path-properties"/> points to a longer, more modern definition of path, which begins as follows:</t>
    <blockquote>
      A sequence of adjacent path elements over which a packet can
      be transmitted, starting and ending with a node.  A path is
      unidirectional.  Paths are time-dependent, i.e., the sequence of
      path elements over which packets are sent from one node to another
      may change.  A path is defined between two nodes.
    </blockquote>
    <t>
    It follows that the general acceptance of a path is a linear sequence of
    nodes, as opposed to a multi-dimensional graph. In the context of this
    document, a path is observed by following one copy of a packet that is
    injected in a Track and possibly replicated within.
    </t>
  </section>
  <section><name>Routing Stretch</name>

  <t>
    RPL is anisotropic, meaning that it is directional, or more exactly polar.
    RPL does not behave the same way "down" with multicast DIO messages that
    form the DODAG and "up" with unicast DAO messages that follow the DODAG.
    This is in contrast with traditional IGPs that operate the same in all
    directions and are thus called isotropic.
  </t>
  <t>The term Routing Stretch denotes the length of a path, as compared with a
    shortest path, which can be a abstract concepts in RPL when the metrics are
    statistical and dynamic, and the concept of short varies with the Objective
    Function.
  </t>
  <t>
    The RPL DODAG optimizes the P2MP (from Root) and MP2P (to Root) paths, but
    the P2P (node to node) traffic has to follow the same DODAG. Following the
    DODAG, the RPL datapath passes via a common parent in Storing Mode and
    via the Root in Non-Storing Mode. This typically involves more hops and
    more latency than the minimum possible for a direct P2P path that an
    isotropic protocol would compute.
    We refer to this elongated path as stretched.
  </t>
  </section>
  <section><name>Track</name>
    <t>A networking graph that can be followed to transport packets with
    equivalent treatment; as opposed to the definition of a path above,
    a Track is not necessarily linear. It may contain multiple paths that
    may fork and rejoin, and may enable the RAW Packet ARQ, Replication,
    Elimination, and Overhearing (PAREO) operations.
    </t>


<figure anchor='TRK'><name>A Track and its Components</name>
              <artwork align="center"><![CDATA[

       A ==> B ==> C -=- F ==> G ==> H     T1       I: Ingress
     /              \   /              \ /          E: Egress
   I                  O                 E -=- T2    T1, T2, T3:
     \              /   \              / \            External
       P ==> Q ==> R -=- T ==> U ==> V     T3         Targets

      I ==> A ==> B ==> C : a segment to targets F and O

         I --> F --> E : a leg to targets T1, T2, T3

        I, A, B, C, F, G, H, E : a path to T1, T2, T3

]]></artwork>
</figure>
    <t>
    This specification builds Tracks that are DODAGs oriented towards a Track
    Ingress, and the forward direction for packets (aka East-West) is from the
    Track Ingress to one of the possibly multiple Track Egress Nodes, which is
    also down the DODAG.
    </t>
    <t>
    The Track may be strictly connected, meaning that the vertices are adjacent, or loosely connected, meaning that the vertices are connected using Segments that are associated to the same Track.
    </t>
  <section><name>TrackID</name>
    <t>
    A RPL Local InstanceID that identifies a Track using the namespace owned by
    the Track Ingress. The TrackID is associated with the IPv6 Address of the
    Track Ingress that is used as DODAGID, and together they form a unique
    identification of the Track
    (see the definition of DODAGID in section 2 of <xref target='RFC6550'/>.
    </t>
  </section>
  <section><name>Namespace</name>
  <t>
    The term namespace is used to refer to the scope of the TrackID. The TrackID
    is locally significant within its namespace. The namespace is identified by
    the DODAGID for the Track. The tuple (DODAGID, TrackID) is globally unique.
    </t>

  </section>
  <section><name>Serial Track</name>
    <t>A Track that has only one path.
    </t>
  </section>
  <section><name>Stand-Alone</name>
    <t>
    A single P-DAO that fully defines a Track, e.g., a Serial Track installed
    with a single Storing Mode Via Information option (SM-VIO).
    </t>
  </section>
  <section><name>Stitching</name>
    <t>
    This specification using the term stitching to indicate that a track is
    piped to another one, meaning that traffic out of the first is injected in
    the other.
    </t>
  </section>
  <section><name>subTrack</name>
    <t>A Track within a Track. As the Non-Storing Mode Via
    Information option (NSM-VIO) can only signal a loose sequence of nodes, it
    takes a number of them to signal a complex Track. Each NSM-VIO for the same
    TrackId but a different Segment ID signals a different subTracks that the
    Track Ingress adds to the topology.
    </t>
  </section>
  <section><name>Leg</name>
    <t>An end-to-end East-West serial path that can be a
    Track by itself or a subTrack of a complex Track.
    With this specification, a Leg is is installed by the Root of the main
    DODAG using Non-Storing Mode P-DAO messages, and it is expressed as a
    loose sequence of nodes that are joined by Track Segments.
    </t>
  </section>
  <section><name>Segment</name>
    <t>
    A serial path formed by a strict sequence of nodes, along which a P-Route is
    installed.
    With this specification, a Segment is typically installed by the Root of the main DODAG using Storing Mode P-DAO messages. A Segment used as
    the topological edge of a Track.
    Since this specification builds only DODAGs,
    all Segments are oriented from Ingress (East) to Egress (West), as opposed
    to the general RAW model, which allows North/South Segments that can be
    bidirectional.
    </t>

  <section><name>Section of a Segment</name>
    <t>
    A continuous subset of a segment that may be replaced while the segment
    remains. for instance, in segment A=>B=>C=>D=>E=>F, say that the  link C to
    D might be misbehaving. The section B=>C=>D=>E in the segment may be
    replaced by B=>C’=>D’=>E to route around the problem. The segment becomes
    A=>B=>C’=>D’=>E=>F.
    </t>

  </section>
  <section><name>Segment Routing and SRH</name>
<t>
   The terms Segment Routing and SRH  refer to using source-routing to hop over segments. In a Non-Storing mode RPL domain, the SRH is typically a RPL Source
   Route Header (the IPv6 RH of type 3) as defined in <xref target='RFC6554'/>.
   </t>
   <t>
   If the network is a 6LoWPAN Network, the expectation is that the
   SRH is compressed and encoded as a 6LoWPAN Routing Header (6LoRH), as
   specified in section 5 of <xref target='RFC8138'/>.
   </t>
   <t>
   On the other hand, if the RPL Network is less constrained and operated in
   Storing Mode, as discussed in <xref target='smmd'/>, the Segment Routing
   operation and the SRH could be as specified in <xref target='RFC8754'/>.
   This specification applies equally to both forms of source routing and SRH.
   </t>

</section>	<!-- end section "Segment Routing and SRH" -->
</section> <!-- Segment -->
</section>
</section>	<!-- end section "Domain Terms" -->

</section>	<!-- end section "Terminology" -->


<section anchor='context'><name>Context and Goal</name>

<section anchor='onrpl'><name>RPL Applicability</name>
<t>
   RPL is optimized for situations where the power is scarce, the bandwidth
   constrained and the transmissions unreliable. This matches the use case of
   an IoT LLN where RPL is typically used today, but also situations of high relative mobility between the nodes in the network (aka swarming), e.g.,
   within a variable set of vehicles with a similar global motion, or a toon of
   drones.
</t><t>
   To reach this goal, RPL is primarily designed to minimize the control plane
   activity, that is the relative amount of routing protocol exchanges vs. data
   traffic, and the amount of state that is maintained in each node. RPL does
   not need converge, and provides connectivity to most nodes most of the time.
</t><t>
    RPL may form multiple topologies called instances. Instances can be
    created to enforce various optimizations through objective functions,
    or to reach out through different Root Nodes.  The concept of objective
    function allows to adapt the activity of the routing protocol to the use
    case, e.g., type, speed, and quality of the LLN links.
</t><t>
    RPL instances operate as ships passing in the night, unbeknownst of one another.
    The RPL Root is responsible to select the RPL Instance that is used
    to forward a packet coming from the Backbone into the RPL domain and set
    the related RPL information in the packets. 6TiSCH leverages RPL for its
    distributed routing operations.
</t><t>
   To reduce the routing exchanges, RPL leverages an anisotropic Distance Vector
   approach, which does not need a global knowledge of the topology, and only
   optimizes the routes to and from the RPL Root, allowing P2P paths to be
   stretched. Although RPL installs its routes proactively, it only maintains
   them lazily, in reaction to actual traffic, or as a slow background activity.
</t><t>
   This is simple and efficient in situations where the traffic is mostly
   directed from or to a central node, such as the control traffic between
   routers and a controller of a Software Defined Networking (SDN) infrastructure or an Autonomic Control Plane (ACP).
</t><t>
   But stretch in P2P routing is counter-productive to both reliability and
   latency as it introduces additional delay and chances of loss. As a result,
   <xref target='RFC6550'/> is not a good fit for the use cases listed in the
   RAW use cases document <xref target= 'I-D.ietf-raw-use-cases'/>, which demand
   high availability and reliability, and as a consequence require both short
   and diverse paths.
</t>

</section>	<!-- end section "RPL Applicability" -->
<section anchor='onrplroute'><name>RPL Routing Modes</name>
<t>
   RPL first forms a default route in each node towards the a Root, and those
   routes together coalesce as a Directed Acyclic Graph upwards.
   RPL then constructs routes to destinations signaled as Targets in the reverse direction,
   down the same DODAG. So do so, a RPL Instance can be operated either in RPL
   Storing or Non-Storing Mode of Operation (MOP).
   The default route towards the Root is maintained aggressively and may change while a packet progresses without causing loops, so the packet will still reach the Root.
</t>
<t>In Non-Storing Mode, each node advertises itself as a Target directly to the
   Root, indicating the parents that may be used to reach self. Recursively, the
   Root builds and maintains an image of the whole DODAG in memory, and
   leverages that abstraction to compute source route paths for the packets to
   their destinations down the DODAG. When a node changes its point(s)
   of attachment to the DODAG, it takes single unicast packet to the Root along
   the default route to update it, and the connectivity is restored immediately;
   this mode is preferable for use cases where internet connectivity is
   dominant, or when, like here, the Root controls the network activity in the
   nodes.
</t>
<t>
   In Storing Mode, the routing information percolates upwards, and each
   node maintains the routes to the subDAG of its descendants down the
   DODAG.  The maintenance is lazy, either reactive upon traffic or as a
   slow background process.  Packets flow via the common parent and the
   routing stretch is reduced vs. Non-Storing, for a better P2P
   connectivity.  On the other hand, a new route takes a longer time to
   propagate to the Root, time for the Distance-Vector protocol to
   operate hop-by-hop, and the Internet connectivity is restored more
   slowly upon movement.
</t>

    <t>

    Either way, the RPL routes are injected by the Target nodes, in a distributed fashion. To complement RPL and eliminate routing stretch, this specification introduces an hybrid mode that combines Storing and Non-Storing operations to build and project routes onto the nodes where they should be installed. This specification uses the term Projected Route (P-Route) to refer to those routes.
    </t>
    <t>
    A P-Route may be installed in either Storing and Non-Storing Mode,
    potentially resulting in hybrid situations where the Mode of the P-
    Route is different from that of the RPL Main DODAG.
    P-Routes can be used as stand-alone segments to reduce the size of the
    source routing headers with loose source routing operations down the main RPL DODAG.
    P-Routes can also be combined with other P-Routes to form a more complex forwarding graph called a Track.
    </t>

</section>	<!-- end section "RPL Routing Modes" -->


	<section><name>Requirements</name>

       <section anchor='loose'><name>Loose Source Routing</name>


	  <t>A RPL implementation operating in a very constrained LLN typically uses
      the Non-Storing Mode of Operation as represented in <xref target='nost'/>.
      In that mode, a RPL node indicates a
      parent-child relationship to the Root, using a destination Advertisement
      Object (DAO) that is unicast from the node directly to the Root,
      and the Root typically builds a source routed path to a destination down
      the DODAG by recursively concatenating this information.
      </t>

          <figure anchor='nost'><name>RPL Non-Storing Mode of operation </name>
            <artwork>
              +-----+
              |     | Border router
              |     |  (RPL Root)
              +-----+                      ^     |        |
                 |                         | DAO | ACK    |
           o    o   o    o                 |     |        | Strict
       o o   o  o   o  o  o o   o          |     |        | Source
      o  o o  o o    o   o   o  o  o       |     |        | Route
      o   o    o  o     o  o    o  o  o    |     |        |
     o  o   o  o   o         o   o o       |     v        v
     o          o             o     o
                       LLN
                       </artwork>
          </figure>

 <t>
   Based on the parent-children relationships expressed in the Non-
   Storing DAO messages, the Root possesses topological information
   about the whole network, though this information is limited to the
   structure of the DODAG for which it is the destination.  A packet
   that is generated within the domain will always reach the Root, which
   can then apply a source routing information to reach the destination
   if the destination is also in the DODAG.  Similarly, a packet coming
   from the outside of the domain for a destination that is expected to
   be in a RPL domain reaches the Root.  It results that the wireless
   bandwidth near the Root is the gating factor for all transmissions
   towards or within the domain, and that the Root is a single point of
   failure for all connectivity to nodes within its domain.

 </t>
 <t>
   The RPL Root must add a source routing header to all downward packets.
   As a network grows, the size of the source routing header augments
   with the depth of the nodes.  In some use cases, a RPL network forms
   long lines along physical structures such as streets for lighting.
   Limiting the packet size is directly beneficial to the energy budget,
   but, mostly, it reduces the chances of frame loss and packet
   fragmentation, which are highly detrimental to the LLN operation.  A
   limited amount of well-targeted routing state would allow the
   source routing operation to be loose as opposed to strict, and save
   packet size.
   Because the capability to store a routing state in every node
   is limited, the decision of which route is installed where can only
   be optimized with a global knowledge of the system, a knowledge that
   the Root or an associated PCE may possess by means that are outside
   of the scope of this specification.
 </t>
 <t>
   Being on path for all packets in Non-Storing mode, the Root may
   determine the number of P2P packets in its RPL domain per source and
   destination, the latency incurred, and the amount of energy and
   bandwidth that is consumed to reach the self and then down, including
   a possible fragmentation when encapsulating larger packets.  Enabling
   a shorter path that would not traverse the Root for select P2P
   source/destinations may improve the latency, lower the consumption of
   constrained resources, free bandwidth at the bottleneck near the
   Root, improve the delivery ratio and reduce the latency for those P2P
   flows with a global benefit for all flows of reducing the load at the
   Root.
 </t>

      <t>
      This requirement is to store a routing state associated with the Main
      DODAG in selected RPL routers, to limit the excursion of the source route
      headers in deep networks. The Root may elide the sequence of routers
      that is installed in the network from its source route header, which
      becomes loose while it is strict in <xref target="RFC6550"/>.
      </t>

      </section> <!-- Loose Source Routing -->
    <section><name>East-West Routes</name>

      <t>
      <xref target="RFC6550"/> optimizes Point-to-Multipoint (P2MP) routes from
      the Root, Multipoint-to-Point (MP2P) routes to the DODAG Root, and
      Internet access when the Root also serves as Border Router.
      All routes are installed North-South (aka up/down) along the RPL DODAG.
      Peer to Peer (P2P) East-West routes in a RPL network will generally
      suffer from some elongated (stretched) path versus a direct (optimized)
      path, since routing between two nodes always happens via a common
      parent, as illustrated in <xref target='stretch'/>:
        </t>

       <figure anchor='stretch'><name>Routing Stretch between S and D via common parent X along North-South Paths</name>
            <artwork>
              ------+---------
                    |          Internet
                 +-----+
                 |     | Border router
                 |     |  (RPL Root)
                 +-----+
                    X
              ^    v   o    o
          ^ o   o  v   o  o  o o   o
         ^  o o  o v    o   o   o  o  o
         ^   o    o  v     o  o    o  o  o
        S  o   o  o   D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>

     <t>As described in <xref target="RFC9008" />, the amount of stretch depends on the Mode of Operation: </t>
    <ul spacing='normal'>
        <li> in Non-Storing Mode, all packets
     routed within the DODAG flow all the way up to the Root of the DODAG. If
     the destination is in the same DODAG, the Root must encapsulate the packet
     to place an RH that has the strict source route information down
     the DODAG to the destination. This will be the case even if the destination
     is relatively close to the source and the Root is relatively far off.
        </li>
        <li>In Storing Mode, unless the destination is a child of the source,
     the packets will follow the default route up the DODAG as well.
     If the destination is in the same DODAG, they will eventually reach a
     common parent that has a route to the destination; at worse, the common
     parent may also be the Root. From that common parent, the packet will
     follow a path down the DODAG that is optimized for the Objective Function
     that was used to build the DODAG.</li>
        </ul>


     <t>
     It results that it is often beneficial to enable East-West P2P routes,
     either if the RPL route presents a stretch from shortest path, or if the
     new route is engineered with a different objective, and that it is
     even more critical in Non-Storing Mode than it is in Storing Mode, because
     the routing stretch is wider.
     For that reason, earlier work at the IETF introduced the
     <xref target='RFC6997'>"Reactive Discovery of Point-to-Point Routes in
     Low Power and Lossy Networks"</xref>, which specifies a distributed method for
     establishing optimized P2P routes. This draft proposes an alternate based
     on a centralized route computation.
     </t>

        <figure anchor='opti2'><name>More direct East-West Route between S and D</name>
            <artwork>
                 +-----+
                 |     | Border router
                 |     |  (RPL Root)
                 +-----+
                    |
              o    o   o    o
          o o   o  o   o  o  o o   o
         o  o o  o o    o   o   o  o  o
         o   o    o  o     o  o    o  o  o
        S>>A>>>B>>C>>>D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>
            <t>
      The requirement is to install additional routes in the RPL routers,
      to reduce the stretch of some P2P routes and maintain the characteristics
      within a given SLO, e.g., in terms of latency and/or reliability.

      </t>
      </section>
      </section> <!-- Requirements -->


<section anchor='tracks'><name>On Tracks</name>
<section anchor='ctracks'><name>Building Tracks With RPL</name>

    <t>
    The concept of a Track was introduced in the <xref target='RFC9030'>
    "6TiSCH Architecture"</xref>, as a collection of potential paths that
    leverage redundant forwarding solutions along the way. This can be a
    DODAG or a more complex structure that is only partially acyclic
    (e.g., per packet).
    </t>
<t>
    With this specification, a Track is shaped as a DODAG, and following the
    directed edges leads to a Track Ingress. Storing Mode P-DAO messages follow
    the direction of the edges to set up routes for traffic that flows the
    other way, towards the Track Egress(es). If there is a single Track Egress,
    then the Track is reversible to form another DODAG by reversing the
    direction of each edge. A node at the Ingress of more than one Segment in a
    Track may use one or more of these Segments to forward a packet inside the
    Track.
    </t>
<t>
   A RPL Track is a collection of (one or more) parallel loose source routed
   sequences of nodes ordered from Ingress to Egress, each forming a Track Leg.
   The nodes that are directly connected, reachable via existing Tracks as
   illustrated in <xref target='nssr'/>  or joined with strict Segments of
   other nodes as shown in <xref target='srpdao'/>.
   The Legs are expressed in RPL Non-Storing Mode and require an encapsulation
   to add a Source Route Header, whereas the Segments are expressed in RPL
   Storing Mode.
</t>
<t>
   A Serial Track comprises provides only one path between Ingress and Egress.
   It comprises at most one Leg. A Stand-Alone Segment implicitly defines a
   Serial Track from its Ingress to Egress.
</t>

<t> A complex Track forms a graph that provides a collection of potential paths
    to provide redundancy for the packets, either as a collection of Legs that
    may be parallel or cross at certain points, or as a more generic DODAG.
</t>


</section><!-- Building Tracks -->
<section anchor='stracks'><name>Tracks and RPL Instances</name>

   <t>
   Section 5.1. of <xref target='RFC6550'/> describes the RPL Instance and
   its encoding. There can be up to 128 global RPL Instances, for which there
   can be one or more DODAGs, and there can be 64 local RPL Instances, with a
   namespace that is indexed by a DODAGID, where the DODAGID is a Unique Local
   Address (ULA) or a Global Unicast Address (GUA) of the Root of the DODAG.
   Bit 0 (most significant) is set to 1 to signal a Local RPLInstanceID, as
   shown in <xref target='rpid'/>. By extension, this specification expresses
   the value of the RPLInstanceID as a single integer between 128 and 191, representing both the Local RPLInstanceID in 0..63 and Bit 0 set.
    </t>

<figure anchor='rpid'><name>Local RPLInstanceID Encoding</name>
              <artwork align="center">
        0 1 2 3 4 5 6 7
       +-+-+-+-+-+-+-+-+
       |1|D|   ID      |  Local RPLInstanceID in 0..63
       +-+-+-+-+-+-+-+-+
 </artwork>
</figure>
   <t>
   A Track is normally associated with a Local RPL Instance which RPLInstanceID
   is used as the TrackID, more in  <xref target='trkid'/>.
   A Track Leg may also be used as a subTrack that extends the RPL main DODAG.
   In that case, the TrackID is set to the global RPLInstanceID of the main
   DODAG, which suffices to identify the routing topology. As opposed to local
   RPL instances, the Track Ingress that encapsulates the packets over a
   subtrack is not Root, and that the source address of the encapsulated packet
   is not used to determine the Track.
   </t>

</section><!-- Tracks and RPL Instances -->
</section><!-- On tracks -->




    <section><name>Serial Track Signaling</name>
<t>
   This specification enables to set up a P-Route along either a Track Leg or a
   Segment. A P-Route is installed and maintained by the Root of the main DODAG
   using an extended RPL DAO message called a Projected DAO (P-DAO), and a Track
   is composed of the combination of one or more P-Routes.
</t>
<t>
   A P-DAO message for a Track signals the TrackID in the RPLInstanceID field.
   In the case of a local RPL Instance, the address of the Track Ingress is
   used as source to encapsulate packets along the Track. The Track is signaled
   in the DODAGID field of the Projected DAO Base Object,
   see <xref target='p-dao-fmt'/>.
</t><t>
   This specification introduces the Via Information Option (VIO) to signal a sequence of hops in a
   Leg or a Segment in the P-DAO messages, either in Storing Mode (SM-VIO) or
   Non-Storing Mode (NSM-VIO). One P-DAO messages contains a single VIO,
   associated to one or more RPL Target Options that signal the destination
   IPv6 addresses that can reached along the Track, more in <xref target='vio'/>.
</t>
<t>
   Before diving deeper into Track Legs and Segments signaling and operation,
   this section provides examples of what how route projection works through
   variations of a simple example. This simple example illustrates the case of
   host routes, though RPL Targets can be prefixes.
</t>
<t>
   Say we want to build a Serial Track from
   node A to E in <xref target='reft'/>, so A can route packets to E's
   neighbors F and G along A, B, C, D and E as opposed to via the Root:
</t>

<figure anchor='reft'><name>Reference Track</name>
              <artwork align="center">
                              /===&gt; F
A ===&gt; B ===&gt; C ===&gt; D===&gt; E &lt;
                              \===&gt; G

 </artwork>
</figure>
<t>
   Conventionally we use  ==&gt; to represent a strict hop and --&gt; for a
   loose hop.
   We use "-to-", such as in C==&gt;D==&gt;E-to-F to represent coma-separated
   Targets, e.g., F is a Target for Segment C==&gt;D==&gt;E.
   In this example, A is Track Ingress, E is Track Egress. C is a stitching
   point. F and G are "external” Targets for the Track, and become reachable
   from A via the Track A(ingress) to E (Egress and implicit Target in
   Non-Storing Mode) leading to F and G (explicit Targets).

</t>
<t>
   <xref target="rpid"/> depicts the format of the RPLInstanceID encoding for a
   local RPLInstanceID .
</t>
<t>
In a general manner the desired outcome is as follows:
</t>

<ul>
<li>Targets are E, F, and G </li>
<li>P-DAO 1 signals C==&gt;D==&gt;E</li>
<li>P-DAO 2 signals A==&gt;B==&gt;C</li>
<li>P-DAO 3 signals F and G via the A--&gt;E Track</li>
</ul>

<t>
   P-DAO 3 may be ommitted if P-DAO 1 and 2 signal F and G as Targets.
</t>
<t>
   Loose sequences of hops must be expressed in Non-Storing Mode, so P-DAO 3
   contains a NSM-VIO. With this specification, the DODAGID to be used by the
   Ingress as  source address is signaled if needed in the DAO base object,
   the via list starts at the first loose hop and matches the source route
   header, and the Egress of a Non-Storing Mode P-DAO is an implicit Target
   that is not listed in the RTO.
</t>



    <section anchor="usms"><name>Using Storing Mode Segments</name>
<t>
    A==&gt;B==&gt;C and C==&gt;D==&gt;E are segments of a same Track.
    Note that the Storing Mode signaling imposes strict continuity in a segment, since the P-DAO is passed hop by hop, as a classical DAO is,
    along the reverse datapath that it signals.
    One benefit of strict routing is that loops are avoided along the Track.
</t>

    <section><name>Stitched Segments</name>


<t>In this formulation:</t>

<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E-to-F,G</li>
<li>P-DAO 2 signals A==&gt;B==&gt;C-to-F,G</li>
</ul>
<t>Storing Mode P-DAO 1 is sent to E and when it is succesfully acknowledged,
   Storing Mode P-DAO 2 is sent to C, as follows:</t>

        <table anchor="PDAOcase11"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'>Field</th>
              <th align='left'>P-DAO 1 to E</th>
              <th align='left'>P-DAO 2 to C</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Storing</td>
              <td align='left'>Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>(DODAGID, TrackID)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>SegmentID</td>
              <td align='left'>1</td>
              <td align='left'>2</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>C, D, E</td>
              <td align='left'>A, B, C</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>F, G</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase11"><name>RIB setting</name>
   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>E</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>C</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>(A, 129)</td></tr>


    </tbody>
        </table>

<t>
    Packets originated by A to F or G do not require an encapsulation
    as the RPI can be placed in the native header chain. For packets that
    it routes, A must encapsulate to add the RPI that signals the trackID;
    the outer headers of the packets that are forwarded along the Track have
    the following settings:
</t>


   <table anchor="Packetcase11"><name>Packet Header Settings</name>  <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>F or G</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X != A</td>
              <td align='center'>F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>
<t>
As an example, say that A has a packet for F. Using the RIB above:
</t>
<ul>
<li>From P-DAO 2: A forwards to B and B forwards to C.</li>
<li>From P-DAO 1: C forwards to D and D forwards to E.</li>
<li>From Neighbor Cache Entry: E delivers the packet to F.</li>
</ul>

    </section><!-- Stitched Segments -->

    <section><name>External routes</name>

<t>In this example, we consider F and G as destinations that are external to the
   Track as a DODAG, as discussed in section 4.1.1. of <xref target='RFC9008'/>.
   We then apply the directives for encapsulating in that case, more in <xref
   target='routing'/>.
</t>
<t>In this formulation, we set up the Track Leg explicitly, which creates less
   routing state in intermediate hops at the expense of larger packets to
   accommodate source routing:</t>
<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E-to-E</li>
<li>P-DAO 2 signals A==&gt;B==&gt;C-to-E</li>
<li>P-DAO 3 signals F and G via the A--&gt;E-to-F,G Track</li>
</ul>
<t>Storing Mode P-DAO 1 and 2, and Non-Storing Mode P-DAO 3, are sent to E, C
 and A, respectively, as follows:</t>

        <table anchor="PDAOcase12"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to E</th>
              <th align='left'>P-DAO 2 to C</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Storing</td>
              <td align='left'>Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>A</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>(DODAGID, TrackID)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>SegmentID</td>
              <td align='left'>1</td>
              <td align='left'>2</td>
              <td align='left'>3</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>C, D, E</td>
              <td align='left'>A, B, C</td>
              <td align='left'>E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E</td>
              <td align='left'>E</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>


<t>
   Note in the above that E is not an implicit Target in Storing mode, so it must be added in the RTO.
</t>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase12"><name>RIB setting</name>
   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>C</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>(A, 129)</td></tr>


    </tbody>
        </table>


        <!--
<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase12o"><name>RIB setting</name>
   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Control Message</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>destination</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>F</td>
              <td align='left'>F</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>G</td>
              <td align='left'>G</td></tr>

          <tr><td align='center'>D</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>E</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'>C</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>D</td>
              <td align='left'>D</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>C</td>
              <td align='left'>C</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>C</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>B</td>
              <td align='left'>B</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'> </td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>E</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>F</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>G</td></tr>


    </tbody>
        </table>
        -->

<t>
    Packets from A to E do not require an encapsulation. The outer headers of
    the packets that are forwarded along the Track have the following settings:
</t>


        <table anchor="Packetcase12"><name>Packet Header Settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>E</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E (X != A), F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>
<t>
As an example, say that A has a packet for F. Using the RIB above:
</t>
<ul>
<li>From P-DAO 3: A encapsulates the packet the Track signaled by P-DAO 3, with the outer header above.
Now the packet destination is E.</li>
<li>From P-DAO 2: A forwards to B and B forwards to C.</li>
<li>From P-DAO 1: C forwards to D and D forwards to E; E decapsulates the packet.</li>
<li>From Neighbor Cache Entry: E delivers packets to F or G.</li>
</ul>
    </section><!-- External routes -->

    <section anchor="srpdao"><name>Segment Routing</name>

<t>In this formulation leverages Track Legs to combine Segments and form a
   Graph. The packets are source routed from a Segment to the next to adapt
   the path. As such, this can be seen as a form of Segment Routing <xref target='RFC8402'/>:</t>

<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E-to-E</li>
<li>P-DAO 2 signals A==&gt;B-to-B,C</li>
<li>P-DAO 3 signals F and G via the A--&gt;C--&gt;E-to-F,G Track</li>
</ul>

<t>Storing Mode P-DAO 1 and 2, and Non-Storing Mode P-DAO 3, are sent to E, B
 and A, respectively, as follows:</t>

        <table anchor="PDAOcase13"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to E</th>
              <th align='left'>P-DAO 2 to B</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Storing</td>
              <td align='left'>Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>A</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>(DODAGID, TrackID)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>SegmentID</td>
              <td align='left'>1</td>
              <td align='left'>2</td>
              <td align='left'>3</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>C, D, E</td>
              <td align='left'>A, B</td>
              <td align='left'>C, E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E</td>
              <td align='left'><!--B,--> C</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>

<t>
   Note in the above that the Segment can terminate at the loose hop as used in
   the example of P-DAO 1 or at the previous hop as done with P-DAO 2.
   Both methods are possible on any Segment joined by a loose Track Leg. P-DAO 1
   generates more signaling since E is the Segment Egress when D could be, but
   has the benefit that it validates that the connectivity between D and E still
   exists.
</t>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase13"><name>RIB setting</name>
           <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>C, E</td>
              <td align='left'>(A, 129)</td></tr>



    </tbody>
        </table>



<t>
    Packets originated at A to E do not require an encapsulation, but
    carry a SRH via C.
    The outer headers of the packets that are forwarded along the Track have
    the following settings:
</t>
        <table anchor="Packetcase13"><name>Packet Header Settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>C till C then E</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E (X != A), F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>
<t>
As an example, say that A has a packet for F. Using the RIB above:
</t>
<ul>
<li>From P-DAO 3: A encapsulates the packet the Track signaled by P-DAO 3, with the outer header above.
Now the destination in the IPv6 Header is C, and a SRH signals the final destination is E.</li>
<li>From P-DAO 2: A forwards to B and B forwards to C.</li>
<li>From P-DAO 3: C processes the SRH and sets the destination in the IPv6 Header to E.</li>
<li>From P-DAO 1: C forwards to D and D forwards to E; E decapsulates the packet.</li>
<li>From the Neighbor Cache Entry: E delivers packets to F or G.</li>
</ul>

    </section><!-- Segment Routing -->



    </section><!-- Using Storing Mode Segments -->




    <section><name>Using Non-Storing Mode joining Tracks</name>

<t>In this formulation:</t>

<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E-to-F,G</li>
<li>P-DAO 2 signals A==&gt;B==&gt;C-to-E,F,G</li>
</ul>

<t>
    A==&gt;B==&gt;C and C==&gt;D==&gt;E are Tracks expressed as Non-Storing P-DAOs.

</t>

    <section><name>Stitched Tracks</name>

    <t>
    Non-Storing Mode P-DAO 1 and 2 are sent to C and A respectively, as follows:
    </t>

        <table anchor="PDAOcase21"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to C</th>
              <th align='left'>P-DAO 2 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>C</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>(DODAGID, TrackID)</td>
              <td align='left'>(C, 131)</td>
              <td align='left'>(A, 131)</td></tr>
          <tr><td align='center'>SegmentID</td>
              <td align='left'>1</td>
              <td align='left'>1</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>D, E</td>
              <td align='left'>B, C</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>F, G</td>
              <td align='left'>E, F, G</td></tr>

    </tbody>
        </table>


<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase21"><name>RIB setting</name>
           <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D, E</td>
              <td align='left'>(C, 131)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C, E, F, G</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B, C</td>
              <td align='left'>(A, 131)</td></tr>


    </tbody>
        </table>



<t>
    Packets originated at A to E, F and G do not require an encapsulation, though it is preferred that A encapsulates and C decapsulates. Either way, they
    carry a SRH via B and C, and C needs to encapsulate to E, F, or G
    to add an SRH via D and E.
    The encapsulating headers of packets that are forwarded along the Track
    between C and E have the following settings:
</t>


        <table anchor="Packetcase21"><name>Packet Header Settings between C and E</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>C</td>
              <td align='center'>D till D then E</td>
              <td align='center'>(C, 131)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F, or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>


<t>As an example, say that A has a packet for F.  Using the RIB above:</t>
<ul>
<li>From P-DAO 2:
   A encapsulates the packet with destination of F in the Track signaled by
   P-DAO 2. The outer header has source A, destination B, an SRH that
   indicates C as the next loose hop, and a RPI indicating a TrackId of 131
   from A's namespace, which is distinct from TrackId of 131 from C's.
</li>
<li>From the SRH:
Packets forwarded by B have source A, destination C, a consumed SRH, and a RPI indicating a TrackId of 131 from A's namespace. C decapsulates.
</li>
<li>
From P-DAO 1:
C encapsulates the packet with destination of F in the Track signaled by P-DAO 1. The outer header has source C, destination D, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 131 from C's namespace. E decapsulates.
</li>
</ul>

    </section><!-- Stitched Tracks -->

    <section><name>External routes</name>


<t>In this formulation:</t>

<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E-to-E</li>
<li>P-DAO 2 signals A==&gt;B==&gt;C-to-C,E</li>
<li>P-DAO 3 signals F and G via the A--&gt;E-to-F,G Track</li>
</ul>

    <t>
    Non-Storing Mode P-DAO 1 is sent to C and Non-Storing Mode P-DAO 2 and 3 are sent A, as follows:
    </t>

        <table anchor="PDAOcase22"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to C</th>
              <th align='left'>P-DAO 2 to A</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>C</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>(DODAGID, TrackID)</td>
              <td align='left'>(C, 131)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 141)</td></tr>
          <tr><td align='center'>SegmentID</td>
              <td align='left'>1</td>
              <td align='left'>1</td>
              <td align='left'>1</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>D, E</td>
              <td align='left'>B, C</td>
              <td align='left'>E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E</td>
              <td align='left'>E</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase22"><name>RIB setting</name>
                   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D, E</td>
              <td align='left'>(C, 131)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C, E</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B, C</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>(A, 141)</td></tr>


    </tbody>
        </table>

<t>
    The encapsulating headers of packets that are forwarded along the Track
    between C and E have the following settings:
</t>


        <table anchor="Packetcase22"><name>Packet Header Settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>C</td>
              <td align='center'>D till D then E</td>
              <td align='center'>(C, 131)</td></tr>
          <tr><td align='center'>Middle</td>
              <td align='center'>A</td>
              <td align='center'>E</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

    <!--
          1.  non Storing Mode P-DAO 1 is sent to C. It has Root = C, SRVIO = D, E, Track ID 131 from C's namespace, Target = E
      2.  non Storing Mode P-DAO 2 is then sent to A. It has Root = A, SRVIO = B, C, Track ID 129 from A's namespace, Target = E
      3.  non Storing Mode P-DAO 3 is then sent to A. It has Root = A, SRVIO = E, Track ID 141 from A's namespace, Target = F, G



    >From P-DAO 3: A encapsulates packets with dest =   F | G. The outer header has source = A, destination = E, and RPI = 141.
    This may recurse with:
    >From P-DAO 2: A encapsulates packets with dest =  E. The outer header has source = A, destination = B, SRH = C and RPI = 129.
    Packets forwarded by B have source= A, destination = C , SRH =, and RPI = 129. C decapsulates.
    >From P-DAO 1: C  encapsulates packets with dest =  E. The outer header has source= C, destination = D, SRH = E and RPI = 131.
    E decapsulates if encapsulated.
    -->


<t>As an example, say that A has a packet for F.  Using the RIB above:</t>
<ul>
<li>
From P-DAO 3: A encapsulates the packet with destination of F in the Track signaled by P-DAO 3. The outer header has source A, destination E, and a RPI indicating a TrackId of 141 from A's namespace. This recurses with:
</li>
<li>
From P-DAO 2: A encapsulates the packet with destination of E in the Track signaled by P-DAO 2. The outer header has source A, destination B, an SRH that indicates C as the next loose hop, and a RPI indicating a TrackId of 129 from A's namespace.
</li>
<li>
From the SRH:
Packets forwarded by B have source A, destination C , a consumed SRH, and a RPI indicating a TrackId of 129 from A's namespace. C decapsulates.
</li>
<li>
From P-DAO 1:
C encapsulates the packet with destination of E in the Track signaled by P-DAO 1. The outer header has source C, destination D, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 131 from C's namespace. E decapsulates.
</li>
</ul>

    </section><!-- External routes -->

    <section anchor="nssr"><name>Segment Routing</name>




<t>In this formulation:</t>

<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E-to-E</li>
<li>P-DAO 2 signals A==&gt;B-to-C</li>
<li>P-DAO 3 signals F and G via the A--&gt;C--&gt;E-to-F,G Track</li>
</ul>

    <t>
    Non-Storing Mode P-DAO 1 is sent to C and Non-Storing Mode P-DAO 2 and 3 are sent A, as follows:
    </t>

        <table anchor="PDAOcase23"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to C</th>
              <th align='left'>P-DAO 2 to A</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>C</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>(DODAGID, TrackID)</td>
              <td align='left'>(C, 131)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 141)</td></tr>
          <tr><td align='center'>SegmentID</td>
              <td align='left'>1</td>
              <td align='left'>1</td>
              <td align='left'>1</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>D, E</td>
              <td align='left'>B</td>
              <td align='left'>C, E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'></td>
              <td align='left'>C</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>



<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase23"><name>RIB setting</name>
                   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D, E</td>
              <td align='left'>(C, 131)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B, C</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>C, E</td>
              <td align='left'>(A, 141)</td></tr>


    </tbody>
        </table>

<t>
    The encapsulating headers of packets that are forwarded along the Track
    between A and B have the following settings:
</t>


        <table anchor="Packetcase231"><name>Packet Header Settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>B till D then E</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Middle</td>
              <td align='center'>A</td>
              <td align='center'>C</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

 <t>
    The encapsulating headers of packets that are forwarded along the Track
    between B and C have the following settings:
</t>


        <table anchor="Packetcase232"><name>Packet Header Settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>C</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

<t>
    The encapsulating headers of packets that are forwarded along the Track
    between C and E have the following settings:
</t>


        <table anchor="Packetcase233"><name>Packet Header Settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>C</td>
              <td align='center'>D till D then E</td>
              <td align='center'>(C, 131)</td></tr>
          <tr><td align='center'>Middle</td>
              <td align='center'>A</td>
              <td align='center'>E</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

    <!--

      1.  non Storing Mode P-DAO 1 is sent to C. It has Root = C, SRVIO = D, E, Track ID 131 from C's namespace, (Target = E is implicit)
      2.  non Storing Mode P-DAO 2 is then sent to A. It has Root = A, SRVIO = B,  Track ID 129 from A's namespace, Target = C
      3.  non Storing Mode P-DAO 3 is then sent to A. It has Root = A, SRVIO = C, E, Track ID 141 from A's namespace, Target = F, G

  -->

<t>As an example, say that A has a packet for F.  Using the RIB above:</t>
<ul>
<li>From P-DAO 3: A encapsulates the packet with destination of F in the Track signaled by P-DAO 3. The outer header has source A, destination C, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 141 from A's namespace. This recurses with:
</li>
<li>
From P-DAO 2: A encapsulates the packet with destination of C in the Track signaled by P-DAO 2. The outer header has source A, destination B, and a RPI indicating a TrackId of 129 from A's namespace. B decapsulates forwards to C based on a sibling connected route.
</li>
<li>
From the SRH: C consumes the SRH and makes the destination E.
</li>
<li>
From P-DAO 1:
C encapsulates the packet with destination of E in the Track signaled by P-DAO 1. The outer header has source C, destination D, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 131 from C's namespace. E decapsulates.
</li>
</ul>

    </section><!-- Segment Routing -->


  </section><!-- Using Non-Storing Mode joining Tracks -->


</section><!-- Example Track Signaling -->


<section anchor='concepts'><name>Complex Tracks</name>

<t>To increase the reliability of the P2P transmission, this specification
   enables to build a collection of Legs between the same Ingress and Egress
   Nodes and combine them with the same TrackID, as shown in <xref
   target="FigLegs"/>.
Legs may cross at the edges of loose hops or remain parallel.
</t><t>
   The Segments that join the loose hops of a Leg are installed with the same
   TrackID as the Leg. But each individual Leg and Segment has its own
   P-RouteID which allows it to be managed separately. When Legs cross within
   respective Segment, the next loose hop (the current destination of the
   packet) indicates which Leg is being followed and a Segment that can reach
   that next loose hop is selected.
</t>
<figure anchor="FigLegs">
          <name>Segments and Tracks</name>
       <artwork align="center" name="" type="" alt="">
<![CDATA[
        CPF               CPF          CPF                 CPF

                       Southbound API

   _-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-
 _-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-

                      +----------+
                      | RPL Root |
                      +----------+
                        (      )
              (                                  )
        (              DODAG                              )
          (                                           )
  (                                                         )
                                                                  )
  <-    Leg 1            B,                            E ->
  <--- Segment 1 A,B ---> <------- Segment 2 C,D,E ------->

             FWD  --z  Relay --z   FWD  --z   FWD          Target 1
         z-- Node  z--  Node  z--  Node  z--  Node --z     /
      --z    (A)        (B) \      (C)        (D)  z--    /
Track                        \                       Track
Ingress                    Segment 5                 Egress - Tgt 2
  (I)                           \                     (E)
      --z                        \                 z--    \
       z-- FWD   --z  FWD  --z  Relay --z  FWD  --z        \
           Node   z-- Node  z-- Node   z-- Node            Target 3
           (F)        (G)       (H)        (J)

  <------ Segment 3 F,G,H ------> <---- Segment 4 J,E ---->
  <-      Leg 2                  H,                    E ->

  <--- Segment 1 A,B ---> <- S5-> <---- Segment 4 J,E ---->
  <-      Leg 3          B,      H,                    E ->
                                                                  )
   (
              (                                        )
]]></artwork>
</figure>


<t>
   Note that while this specification enables to build both Segments inside a
   Leg (aka East-West), such as Segment 2 above which is within Leg 1, and Inter-Leg Segments (aka North-South), such as Segment 2 above which joins
   Leg 1 and Leg 2, it does not signal to the Ingress which Inter-Leg Segments
   are available, so the use of North-South Segments and associated PAREO
   functions is curently limited. The only possibility available at this time
   is to define overlapping Legs as illustrated in <xref target="FigLegs"/>,
   with Leg 3 that is congruent with Leg 1 till node B and congruent with Leg
   2 from node H on, abstracting Segment 5 as an East-West Segment.
 </t>

</section>	<!-- Complex Tracks -->


<section anchor='inandout'><name>Scope and Expectations</name>

<section anchor='mtsch'><name>External Dependencies</name>
<t>
    This specification expects that the RPL Main DODAG is operated in RPL
    Non-Storing Mode to sustain the exchanges with the Root. Based on its
    comprehensive knowledge of the parent-child relationship, the Root can form
    an abstracted view of the whole DODAG topology. This document adds the
    capability for nodes to advertise additional sibling information to
    complement the topological awareness of the Root to be passed on to the PCE,
    and enable the PCE to build more / better paths that traverse those siblings.
 </t><t>
    P-Routes require resources such as routing table space in the
    routers and bandwidth on the links; the amount of state that
    is installed in each node must be computed to fit within the node's memory,
    and the amount of rerouted traffic must fit within the capabilities of
    the transmission links. The methods used to learn the node capabilities and
    the resources that are available in the devices and in the network are out
    of scope for this document. The method to capture and report the LLN link
    capacity and reliability statistics are also out of scope. They may be
    fetched from the nodes through network management functions or other forms
    of telemetry such as OAM.
</t>
</section><!-- External Dependencies -->
<section anchor='ietfr'><name>Positioning vs. Related IETF Standards</name>
<section anchor='extdep'><name>Extending 6TiSCH</name>
<t>
    The <xref target='RFC9030'> "6TiSCH Architecture"</xref> leverages a centralized model that is similar to that of <xref target='RFC8655'>
    "Deterministic Networking Architecture"</xref>,
    whereby the device resources and capabilities are exposed to an external
    controller which installs routing states into the network based on its own
    objective functions that reside in that external entity.
</t>

</section><!-- Extending 6TiSCH -->

<section anchor='mdet'><name>Mapping to DetNet</name>

<t>
   DetNet Forwarding Nodes only understand the simple 1-to-1 forwarding
   sublayer transport operation along a segment whereas the more sophisticated
   Relay nodes can also provide service sublayer functions such as Replication
   and Elimination.
</t>
<t>
   One possible mapping between DetNet and this specification
   is to signal the Relay Nodes as the hops of a Leg and the forwarding Nodes
   as the hops in a Segment that join the Relay nodes as illustrated in <xref
   target="FigLegs"/>.
</t>

</section> <!-- Mapping to DetNet -->
<section anchor='pmce'><name>Leveraging PCE</name>
<t>
    With DetNet and 6TiSCH, the component of the controller that is responsible
    of computing routes is a PCE. The PCE
    computes its routes based on its own objective functions such as described
    in <xref target='RFC4655'/>, and typically controls the routes using the
    PCE Protocol (PCEP) by <xref target='RFC5440'/>.  While this specification
    expects a PCE and while PCEP might effectively be used between the Root and
    the PCE, the control protocol between the PCE and the Root is out of scope.
</t>
    <t>
    This specification also expects a single PCE with a full view of the
    network. Distributing the PCE function for a large network is out of scope.
    This specification uses the RPL Root as a proxy to the PCE. The PCE may be
    collocated with the Root, or may reside in an external Controller.
    In that case, the protocol between the Root and the PCE is out of scope
    and abstracted by / mapped to RPL inside the DODAG; one possibility is for
    the Root to transmit the RPL DAOs with the SIOs that detail the parent/child
    and sibling information.
    </t>

    <t>
    The algorithm to compute the paths and the protocol used by the PCE
    and the metrics and link statistics involved in the computation are also out
    of scope. The effectiveness of the route computation by the PCE depends on
    the quality of the metrics that are reported from the RPL network.
    Which metrics are used and how they are reported is out of scope, but the
    expectation is that they are mostly of long-term, statistical nature, and
    provide visibility on link throughput, latency, stability and availability
    over relatively long periods.
    </t>
</section> <!-- Leveraging PCE -->
<section anchor='mraw'><name>Providing for RAW</name>
    <t>
    The <xref target='I-D.ietf-raw-architecture'>RAW Architecture</xref> extends the definition of
    Track, as being composed of East-West directional segments and North-South
    bidirectional segments, to enable additional path diversity, using Packet ARQ, Replication, Elimination, and Overhearing (PAREO) functions over the available paths, to provide a dynamic balance between the reliability and availability requirements of the flows and the need to conserve energy and spectrum. This specification prepares for RAW by setting up the Tracks, but only forms DODAGs, which are composed  of aggregated end-to-end loose source routed Legs, joined by strict routed Segments, all oriented East-West.
     </t>
    <t>
    The RAW Architecture defines a dataplane extension of the PCE called the Path Selection Engine (PSE), that adapts the use of the path redundancy within a Track to defeat the diverse causes of packet loss.  The PSE controls the forwarding operation of the packets within a Track
    This specification can use but does not impose a PSE and does not provide
    the policies that wouldselect which packets are routed through which
    path within a Track, IOW, how the PSE may use the path redundancy within
    the Track. By default, the use of the available redundancy is limited to simple load balancing, and all the segments are East-West unidirectional only.
    </t>
    <t>
    A Track may be set up to reduce the load around the Root, or to enable
    urgent traffic to flow more directly. This specification does not provide
    the policies that would decide which flows are routed through which Track.
    In a Non-Storing Mode RPL Instance, the Main DODAG provides a default route
    via the Root, and the Tracks provide more specific routes to the Track
    Targets.
    </t>

</section> <!-- Providing for RAW -->

</section><!-- Positioning vs. Related IETF Standards -->

</section><!-- Scope and Expectations -->


</section ><!-- Context and Goal -->

  <section anchor='ext'><name>Extending existing RFCs </name>

  <t>
    This section explains which changes are extensions to existing
    specifications, and which changes are amendments to existing
    specification.
    It is expected that extensions to existing specifications do not cause
    existing code on legacy 6LRs to malfunction, as the extensions will
    simply be ignored.  New code is required for an extension.
    Those 6LRs will be unable to participate in the new mechanisms, but may
    also cause projected DAOs to be impossible to install.
    Amendments to existing specifications are situations where there are
    semantic changes required to existing code, and which may require new unit
    tests to confirm that legacy operations will continue unaffected.
  </t>

    <section anchor='ext6550'><name>Extending RFC 6550</name>
    <t>
    This specification Extends RPL <xref target='RFC6550'/> to enable the Root
    to install East-West routes inside a Main DODAG that is operated as
    Non-Storing Mode. The Root issues a Projected DAO (P-DAO) message
    (see <xref target='extP-DAO'/>) to the Track Ingress; the P-DAO message
    contains a new Via Information Option (VIO) that installs a strict
    or a loose sequence of hops to form respectively a Track Segment or a
    Track Leg.
    </t>
    <t>
    The new P-DAO Request (PDR) is a new message detailed in <xref target='P-DAOreq'/>.
    As per <xref target="RFC6550" /> section 6, if a node receives this message and
    it does not understand this new Code, then discards the message.
    When the root initiates to a node that it has not communicated with
    before, and to which it does not know if this specification has been
    implemented (by means such as capabilities), then the root SHOULD request
    a PDR-ACK.
    </t>

    <t>
    A P-DAO Request (PDR) message
    enables a Track Ingress to request the Track from the Root. The
    resulting Track is also a DODAG for which the Track Ingress is the Root,
    the owner the address that serves as DODAGID and authoritative for the
    associated namespace from which the TrackID is selected. In the
    context of this specification, the installed route appears as a more
    specific route to the Track Targets, and the Track Ingress routes
    the packets towards the Targets via the Track using the longest match as
    usual.
    </t>
    <t>
    To ensure that the PDR and P-DAO messages can flow at most times,
    it is RECOMMENDED that the nodes involved in a Track maintain
    multiple parents in the  Main DODAG, advertise them all to the Root,
    and use them in turn to retry similar packets. It is also
    RECOMMENDED that the Root uses diverse source route paths to retry
    similar messages to the nodes in the Track.
    </t>
    <section anchor='extP-DAO'><name>Projected DAO</name>


   <t>
   Section 6 of <xref target='RFC6550'/> introduces the RPL Control Message
   Options (CMO), including the RPL Target Option (RTO) and Transit Information
   Option (TIO), which can be placed in RPL messages such as the destination
   Advertisement Object (DAO). A DAO message signals routing information to one
   or more Targets indicated in RTOs, providing one hop information at a time in
   the TIO.
   </t>
   <t>
     This document Amends the specification of the DAO to create the P-DAO
     message.
     This Amended DAO is signaled with a new "Projected DAO" (P) flag, see <xref target=
     'p-dao-fmt'/>.
   </t>
   <t>
   A Projected DAO (P-DAO) is a special DAO message generated by the
   Root to install a P-Route formed of multiple hops in its DODAG. This provides
   a RPL-based method to install the Tracks as expected by the 6TiSCH
   Architecture  <xref target='RFC9030'/> as a collection of multiple P-Routes.
   </t>
   <t>
   The Root MUST source the P-DAO message with its address that serves as
   DODAGID for the main DODAG. The receiver MUST NOT accept a P-DAO message that
   is not sent by the Root of its DODAG and MUST ignore such message silently.
   </t>
   <t>
   The 'P' flag is encoded in bit position 2 (to be confirmed by
   IANA) of the Flags field in the DAO Base Object. The Root MUST set it to 1 in
   a Projected DAO message. Otherwise it MUST be set to 0. It is set to 0 in
   Legacy implementations as specified respectively in Sections 20.11 and 6.4 of
   <xref target='RFC6550'/>.
   </t>
   <t>
   The P-DAO is control plane signaling and should not be stuck behind high
   traffic levels. The expectation is that the P-DAO message is sent as high
   QoS level, above that of data traffic, typically with the Network Control
   precedence.
   </t>
<figure anchor='p-dao-fmt'><name>Projected DAO Base Object</name>
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    TrackID    |K|D|P|  Flags  |   Reserved    | DAOSequence   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                   DODAGID field set to the                    |
+               IPv6 Address of the Track Ingress               +
|              used to source encapsulated packets              |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option(s)...
+-+-+-+-+-+-+-+-+
 </artwork>
</figure>


  <t> New fields:</t>
  <dl  spacing='normal'>

  <dt>TrackID:</dt>
    <dd> The local or global RPLInstanceID of the DODAG that serves as Track,
    more in <xref target="trkid"/>

    </dd>

  <dt>P:</dt>
    <dd> <t>1-bit flag (position to be confirmed by IANA).</t>
          <t>
          The 'P' flag is set to 1 by the Root to signal a Projected DAO,
          and it is set to 0 otherwise.
          </t>
          </dd>

  </dl>

    <t>
   The D flag is set to one to signal that the DODAGID field is present.
   It may be set to zero if and only if the destination address of the P-DAO-ACK
   message is set to the IPv6 address that serves as DODAGID and it MUST be set
   to one otherwise, meaning that the DODAGID field MUST then be present.
   </t>
  <t>
   In RPL Non-Storing Mode, the TIO and RTO are combined in a DAO message to
   inform the DODAG Root of all the edges in the DODAG, which are formed by the
   directed parent-child relationships. The DAO message signals to the Root
   that a given parent can be used to reach a given child. The P-DAO message
   generalizes the DAO to signal to the Track Ingress that a Track for which it
   is Root can be used to reach children and siblings of the Track Egress.
   In both cases, options may be factorized and multiple RTOs may be present to
   signal a collection of children that can be reached through the parent or
   the Track, respectively.
   </t>

    </section> <!-- Projected DAO -->
    <section anchor='extP-DAO-ACK'><name>Projected DAO-ACK</name>
    <t> This document also Amends the DAO-ACK message.
    The new P flag signals the projected form.
   </t>
    <t>
   The format of the P-DAO-ACK message is thus as illustrated in
   <xref target='p-dao-ack-fmt'/>:
   </t>

<figure anchor='p-dao-ack-fmt'><name>Projected DAO-ACK Base Object</name>
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    TrackID    |D|P| Reserved  |  DAOSequence  |    Status     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                   DODAGID field set to the                    |
+               IPv6 Address of the Track Ingress               +
|              used to source encapsulated packets              |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option(s)...
+-+-+-+-+-+-+-+-+
 </artwork>
</figure>
  <t> New fields:</t>
  <dl  spacing='normal'>

  <dt>TrackID:</dt>
    <dd> The local or global RPLInstanceID of the DODAG that serves as Track,
    more in <xref target="trkid"/>

    </dd>

  <dt>P:</dt>
    <dd> <t>1-bit flag (position to be confirmed by IANA).</t>
          <t>
          The 'P' flag is set to 1 by the Root to signal a Projected DAO,
          and it is set to 0 otherwise.
          </t>
          </dd>

  </dl>

    <t>
   The D flag is set to one to signal that the DODAGID field is present.
   It may be set to zero if and only if the source address of the P-DAO-ACK
   message is set to the IPv6 address that serves as DODAGID and it MUST be set
   to one otherwise, meaning that the DODAGID field MUST then be present.
   </t>
    </section> <!-- Projected DAO-ACK -->
    <section anchor='extVIO'><name>Via Information Option</name>
    <t>
      This document Extends the CMO to create new objects called the Via
      Information Options (VIO).
      The VIOs are the multihop alternative to the TIO, more in <xref target=
   'vio'/>.
   One VIO is the stateful Storing Mode VIO (SM-VIO); an SM-VIO
   installs a strict hop-by-hop P-Route called a Track Segment. The other is the
   Non-Storing Mode VIO (NSM-VIO); the NSM-VIO installs a loose source-routed
   P-Route called a Track Leg at the Track Ingress, which uses that state to
   encapsulate a packet IPv6_in_IPv6 with a new Routing Header (RH) to the
   Track Egress, more in <xref target= 'routing'/>.
   </t>
   <t>
   A P-DAO contains one or more RTOs to indicate the Target (destinations) that
   can be reached via the P-Route,  followed by exactly one VIO that signals the
   sequence of nodes to be followed, more in <xref target= 'P-DAO'/>.
   There are two modes of operation for the P-Routes, the Storing Mode
   and the Non-Storing Mode, see <xref target= 'sP-DAO'/> and
   <xref target='nsP-DAO'/> respectively for more.
   </t>

    </section> <!-- VIA Information Option -->
    <section anchor='extSIO'><name>Sibling Information Option</name>
   <t>
   This specification adds another CMO called the Sibling Information Option
   (SIO) that is used by a RPL Aware Node (RAN) to advertise a selection of its
   candidate neighbors as siblings to the Root, more in <xref target='rplsib'/>.
   The SIO is placed in DAO messages that are sent directly to the Root of the
   main DODAG.
   </t>

    </section> <!-- Sibling Information Option -->
    <section anchor='extPDR'><name>P-DAO Request</name>
   <t>
   Two new RPL Control Messages are also introduced, to enable a RPL-Aware Node
   to request the establishment of a Track between self as the Track Ingress
   Node and a Track Egress.
   The node makes its request by sending a new P-DAO Request (PDR) Message to
   the Root. The Root confirms with a new PDR-ACK message back to the requester
   RAN, see <xref target='P-DAOreq'/> for more.
   </t>
    </section><!-- P-DAO Request -->

    <section anchor='extRPI'><name>Extending the RPI</name>
         <t>
     Sending a Packet within a RPL Local Instance requires the presence of the abstract RPL Packet Information (RPI) described in section 11.2. of <xref target='RFC6550'/> in the outer IPv6 Header chain (see <xref target='RFC9008'/>). The RPI carries a local RPLInstanceID which, in association with either the source or the destination address in the IPv6 Header, indicates the RPL Instance that the packet follows.

    </t>
    <t>
    This specification extends <xref target='RFC6550'/> to create a new flag that signals that a packet is forwarded along a P-Route.

    </t>
    <dl>
       <dt> Projected-Route 'P':</dt><dd> 1-bit flag. It is set to 1 in the RPI
       that is added in the encapsulation when a packet is sent over a Track.
       It is set to 0 when a packet is forwarded along the main Track,
       including when the packet follows a Segment that joins loose hops
       of the Main DODAG. The flag is not mutable en-route.</dd>
    </dl>
    <t>The encoding of the 'P' flag in native format is shown in <xref target='ext6553'/> while the compressed format is indicated in <xref target='ext8138'/>.
    </t>
    </section> <!-- Extending the RPI -->



   <section anchor='dflag'><name>Additional Flag in the RPL DODAG Configuration Option</name>


   <t>
   The DODAG Configuration Option is defined in Section 6.7.6 of <xref target=
   'RFC6550'/>. Its purpose is extended to distribute configuration
   information affecting the construction and maintenance of the DODAG, as
   well as operational parameters for RPL on the DODAG, through the DODAG.

   This Option was originally designed with 4 bit positions reserved for future use as Flags.
   </t>

<figure anchor="RPLDCO">
          <name>DODAG Configuration Option (Partial View) </name>
       <artwork align="center" name="" type="" alt=""><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type = 0x04 |Opt Length = 14|D| | | |A|       ...           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                     +
                                |4 bits |
]]></artwork>
</figure>

   <t>
   This specification defines a new flag "Projected Routes Support" (D).
   The 'D' flag is encoded in bit position 0 of the reserved Flags in the DODAG
   Configuration Option (this is the most significant bit)(to be confirmed by
   IANA but there's little choice). It is set to 0 in legacy implementations as
   specified respectively in Sections 20.14 and 6.7.6 of <xref target='RFC6550'/>.
   </t>
   <t>
   The 'D' flag is set to 1 to indicate that this specification is enabled in
   the network and that the Root will install the requested Tracks when feasible
   upon a PDR message.
   </t>
   <t>
   Section 4.1.2. of <xref target='RFC9008'/> updates
   <xref target='RFC6550'/> to indicate that the definition of the Flags applies
   to Mode of Operation values from zero (0) to six (6) only.
   For a MOP value of 7, the implementation MUST consider that the Root
   accepts PDR messages and will install Projected Routes.
   </t>
      <t>
   The RPL DODAG Configuration option is typically placed in a DODAG
   Information Object (DIO) message.  The DIO message propagates down
   the DODAG to form and then maintain its structure.  The DODAG
   Configuration option is copied unmodified from parents to children.
   </t>
      <t>
   <xref target='RFC6550'/> states that:
</t>
<blockquote>
   Nodes other than the DODAG root MUST NOT modify this information when propagating the DODAG Configuration option.
</blockquote>
   <t>
   Therefore, a legacy parent propagates the 'D' flag as set
   by the root, and when the 'D' flag is set to 1, it is transparently
   flooded to all the nodes in the DODAG.
  </t>

   </section><!-- New Flag in the RPL DODAG Configuration Option -->
  </section> <!-- Extending RFC 6550 -->


    <section anchor='ext6553'><name>Extending RFC 6553</name>
    <t>
    <xref target='RFC6553'>"The RPL Option for Carrying RPL Information in Data-Plane Datagrams"</xref>describes the RPL Option for use among RPL routers to include the abstract RPL Packet Information (RPI) described in section 11.2. of <xref target='RFC6550'/> in data packets.

    </t>    <t>

    The RPL Option is commonly referred to as the RPI though the RPI is really the abstract information that is transported in the RPL Option. <xref target='RFC9008'/> updated the Option Type from 0x63 to 0x23.

    </t>    <t>

    This specification modifies the RPL Option to encode the 'P' flag as follows:
    </t>
<figure anchor='Rpifmt'><name>Extended RPL Option Format</name>
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |  Option Type  |  Opt Data Len |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|O|R|F|P|0|0|0|0| RPLInstanceID |          SenderRank           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         (sub-TLVs)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>Option Type:</dt><dd>0x23 or 0x63, see <xref target='RFC9008'/>
              </dd>
              <dt>Opt Data Len:</dt><dd> See <xref target='RFC6553'/>
              </dd>
              <dt>'O', 'R' and 'F' flags:</dt><dd> See <xref target='RFC6553'/>.
              Those flags MUST be set to 0 by the sender and ignored by the receiver if the 'P' flag is set.
              </dd>
              <dt> Projected-Route 'P':</dt><dd> 1-bit flag as defined in <xref target='extRPI'/>.
              </dd>
              <dt>RPLInstanceID:</dt><dd> See <xref target='RFC6553'/>. Indicates the TrackId if the 'P' flag is set, as discussed in <xref target='extP-DAO'/>.
              </dd>
              <dt>SenderRank:</dt><dd> See <xref target='RFC6553'/>. This
              field MUST be set to 0 by the sender and ignored by the receiver
              if the 'P'flag is set.
              </dd>

            </dl>

 </section> <!-- Extending RFC 6553 -->
 <section anchor='ext8138'><name>Extending RFC 8138</name>
    <t> The <xref target='RFC8138'>6LoWPAN Routing Header</xref> specification
    introduces a new IPv6 over Low-Power Wireless Personal Area Network
    (6LoWPAN) <xref target='RFC6282'/> dispatch type for use in 6LoWPAN
    route-over topologies, which initially covers the needs of RPL data packet
    compression.
    </t>
    <t>Section 4 of <xref target='RFC8138'/> presents the generic formats of
    the 6LoWPAN Routing Header (6LoRH) with two forms, one Elective that can
    be ignored and skipped when the router does not understand it, and one
    Critical which causes the packet to be dropped when the router cannot
    process it. The 'E' Flag in the 6LoRH indicates its form. In order to skip
    the Elective 6LoRHs, their format imposes a fixed expression of the size,
    whereas the size of a Critical 6LoRH may be signaled in variable forms to
    enable additional optimizations.
    </t>
    <t>When the <xref target='RFC8138'/> compression is used, the Root of the
    Main DODAG that sets up the Track also constructs the compressed routing
    header (SRH-6LoRH) on behalf of the Track Ingress, which saves the
    complexities of optimizing the SRH-6LoRH encoding in constrained code.
    The SRH-6LoRH is signaled in the NSM-VIO, in a fashion that it is ready
    to be placed as is in the packet encapsulation by the Track Ingress.
    </t>

    <t>Section 6.3 of <xref target='RFC8138'/> presents the formats of the
    6LoWPAN Routing Header of type 5 (RPI-6LoRH) that compresses the RPI for
    normal RPL operation. The format of the RPI-6LoRH is not suited for
    P-Routes since the O,R,F flags are not used and the Rank is unknown and
    ignored.
    </t><t>
    This specification introduces a new 6LoRH, the P-RPI-6LoRH that can be
    used in either Elective or Critical 6LoRH form,
    see <xref target='elec6lorhtbl'/> and <xref target='crit6lorhtbl'/>
    respectively. The new 6LoRH MUST be used as a Critical 6LoRH, unless an SRH-6LoRH is present and controls the routing decision, in which case it
    MAY be used in Elective form.
    </t>
    <t>
    The P-RPI-6LoRH is designed to compress the RPI along RPL P-Routes.
    Its format is as follows:
    </t>


<figure anchor='PRpifmt'><name>P-RPI-6LoRH Format</name>
              <artwork align="center">
     0                   1                   2
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|E| Length  |  6LoRH Type   | RPLInstanceID |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 </artwork>
</figure>
          <dl spacing='normal'>
              <dt> Type:</dt><dd> IANA is requested to define the same value of
              the type for both Elective and Critical forms. A type of 8 is suggested.
              </dd>
              <dt> Elective 'E':</dt><dd> See <xref target='RFC8138'/>. The 'E' flag is set to 1 to indicate an Elective 6LoRH, meaning that it can be ignored when forwarding.
              </dd>
              <dt> RPLInstanceID :</dt><dd> In the context of this specification, the RPLInstanceID field signals the TrackID, see <xref target='tracks'/> and <xref target='trkid'/> .
              </dd>

            </dl>

    <t> <xref target='encompression'/> details how a a Track Ingress leverages
    the P-RPI-6LoRH Header as part of the encapsulation of a packet to place it
    into a Track.
    </t>
    </section> <!-- Extending RFC 8138 -->

  </section><!-- Extending existing RFCs  -->
    <section anchor='rplccmo'><name>New RPL Control Messages and Options</name>

    <section anchor='P-DAOreq'><name>New P-DAO Request Control Message</name>

               <t>
   The P-DAO Request (PDR) message is sent by a Node in the Main DODAG to the
   Root. It is a request to establish or refresh a Track where this node is
   Track Ingress, and signals whether an acknowledgment called PDR-ACK is
   requested or not.  A positive PDR-ACK indicates that the Track was built
   and that the Roots commits to maintain the Track for the negotiated lifetime.
   </t>
   <t>
   The main Root MAY indicate to the Track Ingress that the Track was terminated
   before its time and to do so, it MUST uses an asynchronous PDR-ACK with an
   negative status.
   A status of "Transient Failure" (see <xref target=
   "iana-stats-rej"/>) is an indication that the PDR may be retried after a
   reasonable time that depends on the deployment. Other negative status
   values indicate a permanent error; the tentative must be abandoned until
   a corrective action is taken at the application layer or through network
   management.
   </t>
   <t>
   The source IPv6 address of the PDR signals the Track Ingress to-be of the
   requested Track, and the TrackID is indicated in the message itself.
   One and only one RPL Target Option MUST be present in the message.
   The RTO signals the Track Egress, more in <xref target='req'/>.
    <!--
    TODO: A P-DAO parameter option MAY be present as well to provide additional
    information on the requested path.
    -->
    </t>
    <t>
    The RPL Control Code for the PDR is 0x09, to be confirmed by IANA.
    The format of PDR Base Object is as follows:
    </t>

<figure anchor='disupdfmt'><name>New P-DAO Request Format</name>
              <artwork align="center">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    TrackID    |K|R|   Flags   |  ReqLifetime  | PDRSequence   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Option(s)...
 +-+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>TrackID:</dt><dd>8-bit field.
              In the context of this specification, the TrackID field signals the RPLInstanceID of the DODAG formed by the Track, see <xref target='tracks'/> and <xref target='trkid'/>. To allocate a
              new Track, the Ingress Node must provide a value that is not in
              use at this time.
              </dd>
              <dt>K:</dt><dd>The 'K' flag is set to indicate that the recipient
              is expected to send a PDR-ACK back.
              </dd>
              <dt>R:</dt><dd>The 'R' flag is set to request a Complex Track
              for redundancy.
              </dd>
              <dt>Flags:</dt><dd>Reserved. The Flags field MUST initialized to zero by the sender and MUST be ignored by the receiver
              </dd>
              <dt>ReqLifetime:</dt><dd> <t>8-bit unsigned integer.
              The requested lifetime for the Track expressed in Lifetime Units
              (obtained from the DODAG Configuration option).
              </t><t>
              A PDR with a fresher
              PDRSequence refreshes the lifetime, and a PDRLifetime of 0
              indicates that the Track should be destroyed, e.g., when the
              application that requested the Track terminates.
              </t>
              </dd>
              <dt>PDRSequence:</dt><dd>
              <t>8-bit wrapping sequence number,
              obeying the operation in section 7.2 of
              <xref target='RFC6550'/>.
              The PDRSequence is used to correlate a PDR-ACK message with the
              PDR message that triggered it. It is incremented at each PDR
              message and echoed in the PDR-ACK by the Root.
              </t>
              </dd>

            </dl>

    </section> <!-- New P-DAO Request Control Message -->

    <section anchor='rpldisackl'><name>New PDR-ACK Control Message</name>
    <t>
    The new PDR-ACK is sent as a response to a PDR message with the 'K' flag
    set.
    The RPL Control Code for the PDR-ACK is 0x0A, to be confirmed by IANA.
    Its format is as follows:
    </t>

<figure anchor='disackfmt'><name>New PDR-ACK Control Message Format</name>
              <artwork align="center">

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    TrackID    |     Flags     | Track Lifetime|  PDRSequence  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| PDR-ACK Status|                Reserved                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Option(s)...
+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>TrackID:</dt><dd>
             Set to the TrackID indicated in the TrackID field of the PDR
             messages that this replies to.
              </dd>

              <dt>Flags:</dt><dd>Reserved. The Flags field MUST initialized to zero by the sender and MUST be ignored by the receiver
              </dd>

              <dt>Track Lifetime:</dt><dd>
             Indicates that remaining Lifetime for the Track, expressed in
             Lifetime Units; the value of zero (0x00)
              indicates that the Track was destroyed or not created.
              </dd>

              <dt>PDRSequence:</dt><dd> 8-bit wrapping sequence number.
              It is incremented at each PDR message and echoed in the PDR-ACK.
              </dd>


              <dt>PDR-ACK Status:</dt><dd> <t>8-bit field indicating
            the completion.
            The PDR-ACK Status is substructured as indicated in <xref target='rpst'/>:</t>



 <figure anchor='rpst' suppress-title='false'><name>PDR-ACK status Format</name>
       <artwork align="center" name="" type="" alt="">
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |E|R|  Value    |
   +-+-+-+-+-+-+-+-+
</artwork>
 </figure>


    <dl  spacing='compact'>
	<dt>E:</dt><dd> 1-bit flag. Set to indicate a rejection. When not set, the value of 0
    indicates Success/Unqualified Acceptance and other values indicate "not an
    outright rejection".</dd>
	<dt>R:</dt><dd> 1-bit flag. Reserved, MUST be set to 0 by the sender and
    ignored by the receiver.</dd>
	<dt>Status Value:</dt><dd> 6-bit unsigned integer. Values depending on the
    setting of the 'E' flag, see
    <xref target='iana-ack-status'/> and <xref target='iana-nack-status'/>.
    </dd>

	</dl>

    </dd>

    <dt>Reserved:</dt><dd>The Reserved field MUST initialized to zero by the
    sender and MUST be ignored by the receiver
    </dd>

	</dl>

    </section> <!-- New PDR-ACK Control Message -->


     <section anchor='vio'><name>Via Information Options</name>

    <t>A VIO signals the ordered list of IPv6 Via Addresses that constitutes
    the hops of either a Leg (using Non-Storing Mode) a Segment (using storing
    mode) of a Track.  A Storing Mode P-DAO contains one Storing Mode VIO
    (SM-VIO) whereas a Non-Storing Mode P-DAO contains one Non-Storing Mode VIO
    (NSM-VIO)
    </t><t>
    The duration of the validity of a VIO is indicated in a Segment Lifetime
    field. A P-DAO message that contains a VIO with a Segment Lifetime of zero
    is referred as a No-Path P-DAO.
    </t><t>
    The VIO contains one or more SRH-6LoRH header(s), each formed of a
    SRH-6LoRH head and a collection of compressed Via Addresses, except in the
    case of a Non-Storing Mode No-Path P-DAO where the SRH-6LoRH header is not
    present.
    </t><t>
    In the case of a SM-VIO, or if <xref target='RFC8138'/> is not used in the data packets, then the Root MUST use only one SRH-6LoRH per Via Information Option, and the compression is the same forall the addresses, as shown in <xref target='viao'/>, for simplicity.
    </t><t>
    In case of an NSM-VIO and if <xref target='RFC8138'/> is in use in the Main
    DODAG, the Root SHOULD optimize the size of the NSM-VIO if using different
    SRH-6LoRH Types make the VIO globally shorter; this means that more than one SRH-6LoRH may be present.
    </t>
    <t>
    The format of the Via Information Options is as follows:
    </t>
<figure anchor='viao'><name>VIO format (uncompressed form)</name>
              <artwork align="center">
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type        | Option Length |     Flags     |   P-RouteID   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |Segm. Sequence | Seg. Lifetime |        SRH-6LoRH head         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .           Via Address 1 (compressed by RFC 8138)              .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                              ....                             .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .           Via Address n (compressed by RFC 8138)              .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .              Additional SRH-6LoRH Header(s)                   .
    |                                                               |
    .                              ....                             .

 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>Option Type:</dt><dd>0x0E for SM-VIO, 0x0F for NSM-VIO
                                     (to be confirmed by IANA), see =<xref target="ianaRPLCtrlMsgopttbl"/></dd>

              <dt>Option Length:</dt><dd>8-bit unsigned integer, representing the length in octets of the option, not including the Option
              Type and Length fields, see section 6.7.1. of <xref target=
              'RFC6550'/>;
              the Option Length is variable, depending on the number of Via
              Addresses and the compression applied.</dd>


              <dt>P-RouteID:</dt><dd>8-bit field that identifies a component
               of a Track or the Main DODAG as indicated by the TrackID field.
               The value of 0 is used to signal a Serial Track, i.e., made of a
               single segment/Leg. In an SM-VIO, the P-RouteID indicates an
               actual Segment. In an an NSM-VIO, it indicates a Leg, that is a
               serial subTrack that is added to the overall topology of the
               Track.
              </dd>

              <dt>Segment Sequence:</dt><dd>
              <t>8-bit unsigned integer.
              The Segment Sequence obeys the operation in section 7.2 of
              <xref target='RFC6550'/> and the lollipop starts at 255.
              </t><t>
              When the
              Root of the DODAG needs to refresh or update a Segment in a Track,
              it increments the Segment Sequence individually for that Segment.
              </t><t>
              The Segment information indicated in the VIO deprecates any state
              for the Segment indicated by the P-RouteID within the indicated
              Track and sets up the new information.

              </t><t>
              A VIO with a Segment Sequence that is not as fresh as the current
              one is ignored.
              </t><t>
              A VIO for a given DODAGID with the same (TrackID,
              P-RouteID, Segment Sequence) indicates a retry; it MUST NOT
              change the Segment and MUST be propagated or answered as the first
              copy.
              </t>
              </dd>

              <dt>Segment Lifetime:</dt><dd>
              <t>8-bit unsigned integer. The length
              of time in Lifetime Units (obtained from the Configuration
              option) that the Segment is usable.

              </t><t>
              The period starts when a new Segment Sequence is seen. The value
              of 255 (0xFF) represents infinity. The value of zero (0x00)
              indicates a loss of reachability.
              </t>
              </dd>

              <dt>SRH-6LoRH head:</dt><dd>The first 2 bytes of the (first)
              SRH-6LoRH as shown in Figure 6 of <xref target='RFC8138'/>. As an
              example, a 6LoRH Type of 4 means that the VIA Addresses are
              provided in full with no compression.
              </dd>

              <dt>Via Address:</dt><dd>
              <t>An IPv6 ULA or GUA of a node along the Segment.
              The VIO contains one or
              more IPv6 Via Addresses listed in the datapath order from Ingress
              to Egress. The list is expressed in a compressed form as signaled
              by the preceding SRH-6LoRH header.
              </t><t>
              In a Storing Mode P-DAO that updates or removes a section of an
              already existing Segment, the list in the SM-VIO may represent
              only the section of the Segment that is being updated; at the
              extreme, the SM-VIO updates only one node, in which case it
              contains only one IPv6 address.
              In all other cases, the list in the VIO MUST be complete.
              </t><t> In the case of an SM-VIO, the list indicates a sequential
              (strict) path through direct neighbors, the complete list starts
              at Ingress and ends at Egress, and the nodes listed in the VIO,
              including the Egress, MAY be considered as implicit Targets.
              </t><t>
              In the case of an NSM-VIO, the complete list can be loose and
              excludes the Ingress node, starting at the first loose hop and
              ending at a Track Egress; the Track Egress MUST be considered as
              an implicit Target, so it MUST NOT be signaled in a RPL Target
              Option.
              </t>
              </dd>
            </dl>
    </section> <!-- Via Information Options -->
    <section anchor='rplsib'><name>Sibling Information Option</name>

    <t>
    The Sibling Information Option (SIO) provides indication on siblings that
    could be used by the Root to form P-Routes. One or more SIO(s) may be placed
    in the DAO messages that are sent to the Root in Non-Storing Mode.
    </t>
    <t>
   To advertise a neighbor node, the router MUST have an active Address
   Registration from that sibling using <xref target='RFC8505'/>, for an address
   (ULA or GUA) that serves as identifier for the node. If this router also
   registers an address to that sibling, and the link has similar properties in
   both directions, only the router with the lowest Interface ID in its
   registered address needs report the SIO, with the B flag set, and the Root
   will assume symmetry.
    </t>
    <t>
    The format of the SIO is as follows:
    </t>
<figure anchor='siof'><name>Sibling Information Option Format</name>
              <artwork align="center">
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type        | Option Length |S|B|Flags|Comp.|    Opaque     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |            Step in Rank       |          Reserved             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .       Sibling DODAGID (if the D flag not set)               .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .                     Sibling Address                           .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>Option Type:</dt><dd>0x10 for SIO (to be confirmed by IANA),
              see =<xref target="ianaRPLCtrlMsgopttbl"/></dd>

              <dt>Option Length:</dt><dd>8-bit unsigned integer, representing the length in octets of the option, not including the Option
              Type and Length fields, see section 6.7.1. of <xref target=
              'RFC6550'/>.</dd>


              <dt>Reserved for Flags:</dt><dd>MUST be set to zero by the sender
              and MUST be ignored by the receiver.
              </dd>
              <dt>B:</dt><dd>
              1-bit flag that is set to indicate that the connectivity to the sibling
              is bidirectional and roughly symmetrical. In that case, only one of the siblings may
              report the SIO for the hop. If 'B' is not set then the SIO only indicates connectivity
              from the sibling to this node, and does not provide information on the hop from this node
              to the sibling.
              </dd>
              <dt>S:</dt><dd>
              1-bit flag that is set to indicate that sibling belongs to the
              same DODAG. When not set, the Sibling DODAGID is indicated.

              </dd>

              <dt>Flags:</dt><dd>Reserved. The Flags field MUST initialized to zero by the sender and MUST be ignored by the receiver
              </dd>
              <dt>Opaque:</dt><dd>MAY be used to carry information that the node
              and the Root understand, e.g., a particular representation of the
              Link properties such as a proprietary Link Quality Information
              for packets received from the sibling. An industrial Alliance
              that uses RPL for a particular use / environment MAY redefine the
              use of this field to fit its needs.
              </dd>

              <dt>Compression Type:</dt><dd>3-bit unsigned integer. This is the
              SRH-6LoRH Type as defined in figure 7 in section 5.1 of
              <xref target='RFC8138'/> that corresponds to the compression used
              for the Sibling Address and its DODAGID if resent. The Compression
              reference is the Root of the Main DODAG.
              </dd>
              <dt>Step in Rank:</dt><dd>16-bit unsigned integer. This is the
              Step in Rank <xref target='RFC6550'/> as computed by the Objective
              Function between this node and the sibling, that reflects the
              abstract Rank increment that would be computed by the OF if the
              sibling was the preferred parent.
              </dd>

              <dt>Reserved:</dt><dd>The Reserved field MUST initialized to zero
              by the sender and MUST be ignored by the receiver
              </dd>

              <dt>Sibling DODAGID:</dt><dd>2 to 16 bytes, the DODAGID of the
              sibling in a <xref target='RFC8138'/> compressed form as indicated
              by the Compression Type field. This field is present if and only
              if  the D flag is not set.
              </dd>
              <dt>Sibling Address:</dt><dd>2 to 16 bytes, an IPv6 Address of the
              sibling, with a scope that MUST be make it reachable from the Root,
              e.g., it cannot be a Link Local Address. The IPv6 address is
              encoded in the <xref target='RFC8138'/> compressed form
              indicated by the Compression Type field.
              </dd>
            </dl>               <t>
    An SIO MAY be immediately followed by a DAG Metric Container. In that case
    the DAG Metric Container provides additional metrics for the hop from the
    Sibling to this node.
    </t>
    </section> <!-- Sibling Information Option -->




    </section> <!-- New RPL Control Messages and Options -->



    <section anchor='P-DAO'><name>Root Initiated Routing State</name>


<section anchor='setup'><name>RPL Network Setup</name>
<t>

   To avoid the need of Path MTU Discovery, 6LoWPAN links are normally defined
   with a MTU of 1280 (see section 4 of <xref target='RFC4944'/>).
   Injecting packets in a Track typically involves an IP-in-IP encapsulation and
   additional IPv6 Extension Headers. This may cause a fragmentation if the
   resulting packets exceeds the MTU that is defined for the RPL domain.
</t>
 <t>
   Though fragmentation is possible in a 6LoWPAN LLN, e.g., using <xref
   target='RFC4944'/>, <xref target='RFC8930'/>, and/or <xref target='RFC8931'/>,
   it is RECOMMENDED to allow an MTU that is larger than 1280 in the main
   DODAG and allows for the additional headers while exposing only 1280 to the
   6LoWPAN Nodes.
</t>
</section><!--  RPL Network Setup -->
<section anchor='req'><name>Requesting a Track</name>

      <t>
      This specification introduces the PDR message, used by an LLN node to
      request the formation of a new Track for which this node is Ingress.
      Note that the namespace for the TrackID is owned by the Ingress node,
      and in the absence of a PDR, there must be some procedure for the Root to
      assign TrackIDs in that namespace while avoiding collisions, more in
      <xref target='trkid'/>.
      </t>
      <t>
      The PDR signals the desired TrackID and the duration for which the Track should be established. Upon a PDR, the Root MAY install the Track as requested, in which case it answers with a PDR-ACK indicating the granted
      Track Lifetime.
      All the Segments MUST be of a same mode, either Storing or Non-Storing.
      All the Segments MUST be created with the same TrackID and the same DODAGID signaled in the P-DAO.
      </t>
      <t>
      The Root designs the Track as it sees best, and updates / changes the Segments overtime to serve the
      Track as needed.
      Note that there is no protocol element to notify to the requesting Track
      Ingress when changes happen deeper down the Track, so they are transparent
      to the Track Ingress. If the main Root cannot maintain an expected service
      level, then it needs to tear down the Track completely.
      The Segment Lifetime in the P-DAO messages does not need to be aligned to
      the Requested Lifetime in the PDR, or between P-DAO messages for different Segments. The Root may use shorter lifetimes for the Segments
      and renew them faster than the Track is, or longer lifetimes in which case it will need to tear down the Segments if the Track is not renewed.
      </t>
      <t>
      When the Track Lifetime that was returned in the PDR-ACK is close to
      elapse - vs. the trip time from the node to the Root, the requesting node
      SHOULD resend a PDR using the TrackID in the PDR-ACK to extend the
      lifetime of the Track, else the Track will time out and the Root will tear
      down the whole structure.
      </t>
      <t>
      If the Track fails and cannot be restored, the
      Root notifies the requesting node asynchronously with a PDR-ACK
      with a Track Lifetime of 0, indicating that the Track has failed, and
      a PDR-ACK Status indicating the reason of the fault.
      </t>
      </section><!-- Requesting a Track  -->


     <section anchor='trkid'><name>Identifying a Track</name>

     <t>
     RPL defines the concept of an Instance to signal an individual
     routing topology, and multiple topologies can coexist in the same network.
     The RPLInstanceID is tagged in the RPI of every packet to signal which
     topology the packet actually follows.
     </t>
     <t>
     This draft leverages the RPL Instance model as follows:
     </t>
   <ul spacing='normal'>
     <li>
     <t>
     The Root MAY use P-DAO messages to add better routes in the main (Global)
     RPL Instance in conformance with the routing objectives in that Instance.
     </t>
     <t>
     To achieve this, the Root MAY install a Segment along a path down the main Non-Storing Mode DODAG. This enables a loose source routing and reduces the size of the Routing Header, see <xref target='loose'/>.
     The Root MAY also install a Track Leg across the Main DODAG to complement
     the routing topology.
     </t>
     <t>
     When adding a P-Route to the RPL Main DODAG, the Root MUST set the
     RPLInstanceID field of the P-DAO Base Object (see section 6.4.1. of <xref
     target='RFC6550'/>) to the RPLInstanceID of the Main DODAG, and MUST NOT
     use the DODAGID field. A P-Route provides a longer match to the Target
     Address than the default route via the Root, so it is preferred.
     </t>
     </li>
     <li>
     <t>
     The Root MAY also use P-DAO messages to install a Track as an independent
     routing topology (say, Traffic Engineered) to achieve particular routing
     characteristics from an Ingress to an Egress Endpoints. To achieve
     this, the Root MUST set up a local RPL Instance (see section 5 of <xref
     target='RFC6550'/>), and the Local RPLInstanceID serves as TrackID.
     The TrackID MUST be unique for the IPv6 ULA or GUA of the Track Ingress that serves as DODAGID for the Track.
     </t>
     <t>
     This way, a Track is uniquely identified by the tuple (DODAGID, TrackID)
     where the TrackID is always represented with the D flag set to 0 (see
     also section 5.1. of <xref target='RFC6550'/>), indicating when used in an
     RPI that the source address of the IPv6 packet signals the DODAGID.
     </t>
     <t>
     The P-DAO Base Object MUST indicate the tuple (DODAGID, TrackID) that
     identifies the Track as shown in <xref target='p-dao-fmt'/>, and the
     P-RouteID that identifies the P-Route MUST be signaled in the VIO as shown
     in <xref target='viao'/>.
     </t>
     <t>
     The Track Ingress is the Root of the DODAG ID formed by the local RPL
     Instance. It owns the namespace of its TrackIDs, so it can pick any
     unused value to request a new Track with a PDR. In a particular deployment
     where PDR are not used, a portion of the namespace can be administratively
     delegated to the main Root, meaning that the main Root is authoritative for
     assigning the TrackIDs for the Tracks it creates.
    </t>
     <t>
     With this specification, the Root is aware of all the active Tracks, so it
     can also pick any unused value to form Tracks without a PDR. To avoid a
     collision of the Root and the Track Ingress picking the same value at the
     same time, it is RECOMMENDED that the Track Ingress starts allocating the
     ID value of the Local RPLInstanceID (see section 5.1. of <xref target=
     'RFC6550'/>) used as TrackIDs with the value 0 incrementing, while the Root
     starts with 63 decrementing.
     </t>

     </li>


  </ul>
     </section><!-- Identifying a Track -->


      <section anchor='inst'><name>Installing a Track</name>



 <t>
   A Serial Track can be installed by a single P-Route that signals the sequence of consecutive nodes, either in Storing Mode as a single-Segment Track, or in Non-Storing Mode as a single-Leg Track. A single-Leg Track can be installed as a loose Non-Storing Mode P-Route, in which case the next loose entry must recursively be reached over a Serial Track.
   </t>
   <t>
   A Complex Track can be installed as a collection of P-Routes with the same DODAGID and Track ID. The Ingress of a Non-Storing Mode P-Route is the owner and Root of the DODAGID. The Ingress of a Storing Mode P-Route must be either the owner of the DODAGID, or a hop of a Leg of the same Track. In the latter case, the Targets of the P-Route must include the next hop of the Leg if there is one, to ensure forwarding continuity.
   In the case of a Complex Track, each Segment is maintained independently and
   asynchronously by the Root, with its own lifetime that may be shorter, the
   same, or longer than that of the Track.
   </t>

   <t>A route along a Track for which the TrackID is not the RPLInstanceID of
   the Main DODAG MUST be installed with a higher precedence than the routes
   along the Main DODAG, meaning that:
   </t>
   <ul>
   <li>Longest match MUST be the prime comparison for routing.
   </li>
   <li>In case of equal length match, the route along the Track MUST be
   preferred vs. the one along the Main DODAG.
   </li>
   <li>There SHOULD NOT be 2 different Tracks leading to the same Target from
   same Ingress node, unless there's a policy for selecting which packets use
   which Track; such policy is out of scope.
   </li>
   <li>A packet that was routed along a Track MUST NOT be routed along the main
   DODAG again; if the destination is not reachable as a neighbor by the node
   where the packet exits the Track then the packet MUST be dropped.
   </li>
   </ul>


     <section anchor='trkpdao'><name>Signaling a Projected Route</name>
         <t>
    This draft adds a capability whereby the Root of a main RPL DODAG installs
    a Track as a collection of P-Routes, using a Projected-DAO (P-DAO) message
    for each individual Track Leg or Segment.
    The P-DAO signals a collection of Targets in the RPL Target Option(s) (RTO). Those Targets can be reached via a sequence of routers indicated in a VIO.
     </t> <t>
    Like a classical DAO message, a P-DAO causes a change of state only if it is
    "new" per section 9.2.2. "Generation of DAO Messages" of the <xref target='RFC6550'> RPL specification</xref>; this is determined using
    the Segment Sequence information from the VIO as opposed to the Path
    Sequence from a TIO. Also, a Segment Lifetime of 0 in a VIO indicates that the P-Route associated to the Segment is to be removed. There are two Modes
    of operation for the P-Routes, the Storing and the Non-Storing Modes.
     </t> <t>
    A P-DAO message MUST be sent from the address of the Root that serves as
    DODAGID for the Main DODAG. It MUST contain either exactly one sequence of
    one or more RTOs followed one VIO, or any number of sequences of one or more
    RTOs followed by one or more TIOs. The former is the normal expression for
    this specification, where as the latter corresponds to the variation for
    lesser constrained environments described in <xref target='bfd'/>.
    </t> <t>
    A P-DAO that creates or updates a Track Leg MUST be sent to a GUA or a ULA
    of the Ingress of the Leg; it must contain the full list of hops in the
    Leg unless the Leg is being removed.
    A P-DAO that creates a new Track Segment MUST be sent to a GUA or a ULA
    of the Segment Egress and MUST signal the full list of hops in Segment; a
    P-DAO that updates (including deletes) a section of a Segment MUST be
    sent to the first node after the modified Segment and signal the full
    list of hops in the section starting at the node that immediately
    precedes the modified section.
    </t> <t>
    In Non-Storing Mode, as discussed in <xref target='nsP-DAO'/>, the Root
    sends the P-DAO to the Track Ingress where the source-routing state is
    applied, whereas in Storing Mode, the P-DAO is sent to the last node on the
    installed path and forwarded in the reverse direction, installing a Storing
    Mode state at each hop, as discussed in <xref target='sP-DAO'/>.
    In both cases the Track Ingress is the owner of the Track, and it generates the P-DAO-ACK when the installation is successful.
    </t>
     <t>
    If the 'K' Flag is present in the P-DAO, the P-DAO must be acknowledged
    using a DAO-ACK that is sent back to the address of the Root from which the
    P-DAO was received. In most cases, the first node of the Leg, Segment,
    or updated section of the Segment is the node that sends the acknowledgment.
    The exception to the rule is when an intermediate node in a Segment fails
    to forward a Storing Mode P-DAO to the previous node in the SM-VIO.
   </t>
    <t>
   In a No-Path Non-Storing Mode P-DAO, the SRH-6LoRH MUST NOT be present in the
   NSM-VIO; the state in the Ingress is erased regardless. In all other cases, a
   VIO MUST contain at least one Via Address, and a Via Address MUST NOT be
   present more than once, which would create a loop.
   </t>
   <t>
   A node that processes a VIO MAY verify whether one of these conditions
   happen, and when so, it MUST ignore the P-DAO and reject it with a RPL
   Rejection Status of "Error in VIO" in the DAO-ACK, see <xref target='iana-stats-rpl-rej'/>.
   </t><t>
   Other errors than those discussed explicitely that prevent the installing the
   route are acknowledged with a RPL Rejection Status of "Unqualified Rejection" in the DAO-ACK.
    </t>
      </section><!-- Signaling a Projected Route -->



    <section anchor='sP-DAO'><name>Installing a Track Segment with a Storing Mode P-Route</name>

   <t>As illustrated in <xref target='sdf'/>, a Storing Mode P-DAO installs a
   route along the Segment signaled by the SM-VIO towards the Targets indicated in the Target Options.
   The Segment is to be included in a DODAG indicated by the P-DAO Base Object,
   that may be the one formed by the RPL Main DODAG, or a Track associated
   with a local RPL Instance.
   </t>

      <figure anchor='sdf'><name>Projecting a route</name>
        <artwork>
        ------+---------
              |          Internet
              |
           +-----+
           |     | Border router
           |     |  (RPL Root)
           +-----+                      |     ^                   |
              |                         | DAO | ACK               |
        o    o   o    o                 |     |                   |
    o o   o  o   o  o  o o   o          |  ^       | Projected    .
   o  o o  o o    o   o   o  o  o       |  | DAO   | Route        .
   o   o    o  o     o  o    o  o  o    | ^        |              .
  o  o   o  o   o         o   o o       v | DAO    v              .
  o          o   LLN   o   o     o                                |
      o o   o        o     o              Loose Source Route Path |
   o       o      o    o                                          v
    </artwork>
         </figure>


    <t>
     In order to install the relevant routing state along the Segment ,
     the Root sends a unicast P-DAO message to the Track Egress router of the routing Segment that is being installed. The P-DAO message contains a SM-VIO with the strict sequence of Via Addresses. The SM-VIO follows
     one or more RTOs indicating the Targets to which the Track leads. The SM-VIO contains a Segment Lifetime for which the state is to be maintained.
     </t><t>
     The Root sends the P-DAO directly to the Egress node of the Segment.
     In that P-DAO, the destination IP address matches the last Via Address in
     the SM-VIO. This is how the Egress recognizes its role. In a similar
     fashion, the Segment Ingress node recognizes its role as it matches first
     Via Address in the SM-VIO.
     </t><t>
     The Egress node of the Segment is the only node in the path that does not
     install a route in response to the P-DAO; it is expected to be already able
     to route to the Target(s) based on its existing tables.
     If one of the Targets is not known, the node MUST answer to the Root
     with a DAO-ACK listing the unreachable Target(s) in an RTO and a rejection
     status of "Unreachable Target".
    </t><t>
     If the Egress node can reach all the Targets, then it forwards the P-DAO
     with unchanged content to its predecessor in the Segment as indicated in
     the list of Via Information options, and recursively the message is
     propagated
     unchanged along the sequence of routers indicated in the P-DAO, but in the
     reverse order, from Egress to Ingress.
     </t><t>
     The address of the predecessor to be used as destination of the propagated
     DAO message is found in the Via Address the precedes the one
     that contain the address of the propagating node, which is used as source
     of the message.
    </t><t>
    Upon receiving a propagated DAO, all except the Egress router MUST install a
    route towards the DAO Target(s) via their successor in the SM-VIO. A router
    that cannot store the routes to all the Targets in a P-DAO MUST reject the
    P-DAO by sending a DAO-ACK to the Root with a Rejection Status of "Out of
    Resources" as opposed to forwarding the DAO to its predecessor in the list.
    The router MAY install additional routes towards the VIA Addresses that are
    the SM-VIO after self, if any, but in case of a conflict or a lack of
    resource, the route(s) to the Target(s) are the ones that must be installed
    in priority.
    </t>
     <t>
     If a router cannot reach its predecessor in the SM-VIO, the router MUST send the DAO-ACK to the Root with a Rejection Status of "Predecessor Unreachable".
    </t>
    <t>
     The process continues till the P-DAO is propagated to Ingress router of
     the Segment, which answers with a DAO-ACK to the Root. The Root always
     expects a DAO-ACK, either from the Track Ingress with a positive status
     or from any node along the segment with a negative status. If the DAO-ACK
     is not received, the Root may retry the DAO with the same TID, or tear
     down the route.
    </t>
    </section>  <!-- Installing a Track Segment with a Storing Mode P-Route -->





    <section anchor='nsP-DAO'><name>Installing a Track Leg with a Non-Storing Mode P-Route</name>



   <t>As illustrated in <xref target='nsdf'/>,
   a Non-Storing Mode P-DAO installs a source-routed path within the Track indicated by the P-DAO Base Object, towards the Targets indicated in the Target Options. The source-routed path requires a Source-Routing header which implies an IP-in-IP encapsulation to add the SRH to an existing packet. It is sent to the Track Ingress which creates a tunnel associated with the Track, and
   connected routes over the tunnel to the Targets in the RTO. The tunnel encapsulation MUST incorporate a routing header via the list addresses listed in the VIO in the same order. The content of the NSM-VIO starting at the first SRH-6LoRH header MUST be used verbatim by the Track Ingress when it encapsulates a packet to forward it over the Track.
   </t>

          <figure anchor='nsdf'><name>Projecting a Non-Storing Route</name>
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border router
              |     |  (RPL Root)
              +-----+                    |  P  ^ ACK
                 |        Track          | DAO |
           o    o   o  o  Ingress X      V     |   X
       o o   o  o   o  o     o   X   o             X Source
      o  o o  o o    o   o  o    X  o  o           X Routed
      o   o    °  o     o   o   o X     o          X Segment
     o  o   o  o   o  o    o  o     X Egress       X
        o  o  o  o             o    |
                                  Target
       o       o     LLN          o    o
     o          o             o     o
</artwork>
          </figure>
   <t>
   The next entry in the source-routed path must be either a neighbor of the
   previous entry, or reachable as a Target via another P-Route, either
   Storing or Non-Storing, which implies that the nested P-Route has to be
   installed before the loose sequence is, and that P-Routes must be installed
   from the last to the first along the datapath.
   For instance, a Segment of a Track must be installed before the Leg(s) of
   the same Track that use it, and stitched Segments must be installed in
   order from the last that reaches to the Targets to the first.
   </t>
   <t>
   If the next entry in the loose sequence is reachable over a Storing Mode P-Route, it MUST be the Target of a Segment and the Ingress of a next segment, both already setup; the segments are associated with the same Track, which avoids the need of an additional encapsulation. For instance, in
   <xref target="srpdao"/>, Segments A==>B-to-C and C==>D==>E-to-F must be
   installed with Storing Mode P-DAO messages 1 and 2 before the Track A-->C-->E-to-F that joins them can be installed with Non-Storing Mode P-DAO 3.
   </t>
   <t>
   Conversely, if it is reachable over a Non-Storing Mode P-Route, the next
   loose source-routed hop of the inner Track is a Target of a previously
   installed Track and the Ingress of a next Track, which requires a de- and a
   re-encapsulation when switching the outer Tracks that join the loose hops.
   This is examplified in <xref target="nssr"/> where Non-Storing Mode P-DAO 1
   and 2 install strict Tracks that Non-Storing Mode P-DAO 3 joins as a super
   Track. In such a case, packets are subject to double IP-in-IP encapsulation.
  </t>
  </section> <!-- Installing a Track Segment with a Storing Mode P-Route -->

      </section><!-- Installing a Track  -->


    <section anchor='teardown'><name>Tearing Down a P-Route</name>
    <t>
    A P-DAO with a lifetime of 0 is interpreted as a No-Path DAO and results in
    cleaning up existing state as opposed to refreshing an existing one or
    installing a new one. To tear down a Track, the Root must tear down all the
    Track Segments and Legs that compose it one by one.
    </t>
    <t>
    Since the state about a Leg of a Track is located only on the Ingress Node,
    the Root cleans up the Leg by sending an NSM-VIO to the Ingress indicating
    the TrackID and the P-RouteID of the Leg being removed, a Segment Lifetime
    of 0 and a newer Segment Sequence. The SRH-6LoRH with the Via Addresses in
    the NSM-VIO are not needed; it SHOULD not be placed in the message and MUST
    be ignored by the receiver. Upon that NSM-VIO, the Ingress node removes all
    state for that Track if any, and replies positively anyway.
    </t>
    <t>
    The Root cleans up a section of a Segment by sending an SM-VIO to the last
    node of the Segment, with the TrackID and the P-RouteID of the Segment being
    updated, a Segment Lifetime of zero (0) and a newer Segment Sequence.
    The Via Addresses in the SM-VIO indicates the section of the Segment being
    modified, from the first to the last node that is impacted. This can be the
    whole Segment if it is totally removed, or a sequence of one or more nodes
    that have been bypassed by a Segment update.
    </t>
    <t>
    The No-Path P-DAO is forwarded normally along the reverse list, even if the
    intermediate node does not find a Segment state to clean up. This results in
    cleaning up the existing Segment state if any, as opposed to refreshing an
    existing one or installing a new one.
    </t>
    </section><!-- Tearing Down a P-Route -->

     <section anchor='maintain'><name> Maintaining a Track</name>
     <t>
     Repathing a Track Segment or Leg may cause jitter and packet misordering.
     For critical flows that require timely and/or
     in-order delivery, it might be necessary to deploy the PAREO functions
     <xref target='I-D.ietf-raw-architecture'/> over a highly redundant Track.
     This specification allows to use more than one Leg for a Track, and 1+N
     packet redundancy.
     </t>
    <t>
     This section provides the steps to ensure that no packet is lost due to
     the operation itself.
     This is ensured by installing the new section from its last node to the
     first, so when an intermediate node installs a route along the new section,
     all the downstream nodes in the section have already installed their own.
     The disabled section is removed when the packets in-flight are forwarded
     along the new section as well.
     </t>
    <section anchor='maintainS'><name>Maintaining a Track Segment</name>

    <t>
    To modify a section of a Segment between a first node and a second, downstream
    node (which can be the Ingress and Egress), while conserving those nodes
    in the Segment, the Root sends an SM-VIO to the second node indicating the
    sequence of nodes in the new section of the Segment. The SM-VIO indicates
    the TrackID and the P-RouteID of the Segment being updated, and a newer
    Segment Sequence. The P-DAO is propagated from the second to the first node
    and on the way, it updates the state on the nodes that are common to the old
    and the new section of the Segment and creates a state in the new nodes.
    </t>
    <t>
    When the state is updated in an intermediate node, that node might still
    receive packets that were in flight from the Ingress to self over the
    old section of the Segment. Since the remainder of the Segment is already
    updated, the packets are forwarded along the new version of the Segment from
    that node on.
    </t>
    <t>
    After a reasonable time to enable the deprecated sections to empty, the Root
    tears down the remaining section(s) of the old segments are teared down as
    described in <xref target='teardown'/>.
    </t>
    </section>  <!-- Maintaining a Track Segment -->

    <section anchor='maintainT'><name>Maintaining a Track Leg</name>

     <t>This specification allows the Root to add Legs to a Track by sending
     a Non-Storing Mode P-DAO to the Ingress associated to the same TrackID,
     and a new Segment ID. If the Leg is loose, then the Segments that join
     the hops must be created first.  It makes sense to add a new Leg before
     removing one that is becoming excessively lossy, and switch to the new
     Leg before removing the old. Dropping a Track before the new one is
     installed would reroute the traffic via the root; this may augment the
     latency beyond acceptable thresholds, and load the network near the root.
     This may also cause loops in the case of stitched Tracks; the packets that
     cannot be injected in the second Track may be routed back at  reinjected
     at the Ingress of the first.
     </t>
     <t>
     It is also possible to update a Track Leg by sending a Non-Storing Mode
     P-DAO to the Ingress with the same Segment ID, an incremented Segment
     Sequence, and the new complete list of hops in the NSM-VIO.
     Updating a live Leg means changing one or more of the intermediate loose
     hops, and involves laying out new Segments from and to the new loose hops
     before the NSM-VIO for the new Leg is issued.
     </t>
    <t>
    Packets that are in flight over the old version of the Track Leg still
    follow the old source route path over the old Segments.
    After a reasonable time to enable the deprecated Segments to empty, the Root
    tears down those Segments as described in <xref target='teardown'/>.
    </t>

    </section>  <!-- Maintaining a Track Leg -->

    </section> <!-- Maintaining a Track -->

   <section anchor='routing'><name>Encapsulating and Forwarding Along a Track</name>



    <t>
   When injecting a packet in a Track, the Ingress router must
   encapsulate the packet using IP-in-IP to add the Source Routing Header with
   the final destination set to the Track Egress.
   </t>

    <t>
     All properties of a Track operations are inherited form the main RPL
     Instance that is used to install the Track. For instance, the use of
     compression per <xref target='RFC8138'/> is determined by whether it is
     used in the RPL Main DODAG, e.g., by setting the "T" flag <xref target=
     'RFC9035'/> in the RPL configuration option.
   </t>
    <t>
    The Track Ingress that places a packet in a Track encapsulates it with an
    IP-in-IP header, a Routing Header, and an IPv6 Hop-by-Hop Option Header that
    contains the RPL Packet Information (RPI) as follows:
    </t>
    <ul>
    <li>
      In the uncompressed form the source of the packet is the  address that
      this router uses as DODAGID for the Track, the destination is the first
      Via Address in the NSM-VIO, and the RH is a
      Source Routing Header (SRH) <xref target='RFC6554'/> that contains the
      list of the remaining Via Addresses terminating by the Track Egress.
    </li>
    <li>
    <t>
    The preferred alternate in a network where 6LoWPAN Header Compression
    <xref target='RFC6282'/> is used is to leverage <xref target='RFC8025'>
    "IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging
    Dispatch"</xref> to compress the RPL artifacts as indicated in
    <xref target='RFC8138'/>.
    </t>
    <t>
    In that case, the source routed header is the exact copy of the (chain of) SRH-6LoRH found in the NSM-VIO, also terminating by the Track Egress.
    The RPI-6LoRH is appended next, followed by an IP-in-IP 6LoRH Header  that indicates the Ingress router in the Encapsulator Address field, see as a similar case Figure 20 of <xref target='RFC9035'/>.

    </t>
    </li>
    </ul>

     <t>
     To signal the Track in the packet, this specification leverages the RPL
     Forwarding model follows:
     </t>




     <ul spacing='normal'>
     <li>
      <t>
     In the data packets, the Track DODAGID and the TrackID MUST be respectively
     signaled as the IPv6 Source Address and the RPLInstanceID field of the RPI
     that MUST be placed in the outer chain of IPv6 Headers.
      </t>
      <t>
     The RPI carries a local RPLInstanceID called the TrackID, which, in association with the DODAGID, indicates the Track along which the packet is forwarded.
      </t>
     <t>
     The D flag in the RPLInstanceID MUST be set to 0 to indicate that the source address in the IPv6 header is set ot the DODAGID, more
     in <xref target='trkid'/>.
     </t>
     </li>
     <li>
      <t>
      This draft conforms to the principles of <xref target='RFC9008'/> with regards to packet forwarding and encapsulation along a Track, as follows:
      </t>

      <ul>
      <li>
      With this draft, the Track is a RPL DODAG. From the perspective of that
      DODAG, the Track Ingress is the Root, the Track Egress is a RPL-Aware
      6LR, and neighbors of the Track Egress that can be reached via the Track,
      but are external to it, are external destinations and treated as
      RPL-Unaware Leaves (RULs). The encapsulation rules in <xref target=
      'RFC9008'/> apply.
      </li><li>
      If the Track Ingress is the originator of the packet and the Track Egress
      is the destination of the packet, there is no need for an encapsulation.
      </li><li>
      So the Track Ingress must encapsulate the traffic that it did not originate, and add an RPI.
      </li>
      </ul>

     <t>
     A packet that is being routed over the RPL Instance associated to a first
     Non-Storing Mode Track MAY be placed (encapsulated) in a second Track to
     cover one loose hop of the first Track as discussed in more details <xref
     target="nssr"/>.
     On the other hand, a Storing Mode Track must be strict and a packet that
     it placed in a Storing Mode Track MUST follow that Track till the Track
     Egress.
     </t>

     </li>

    </ul>
    <t>
    The forwarding of a packet along a track will fail if the Track continuity
    is broken,e.g.:
    </t>

   <ul>
    <li>
     In the case of a strict path along a Segment, if the next strict hop is not
     reachable, the packet is dropped.
    </li>
    <li>
      In the case of a loose source-routed path, when the loose next hop is not
      a neighbor, there must be a Segment of the same Track to that loose next hop. When that is the case the packet is
      forwarded to the next hop along that segment, or a common neighbor with the
      loose next hop, on which case the packet is forwarded to that neighbor, or
      another Track to the loose next hop for which this node or a neighbor is
      Ingress; in the last case, another encapsulation takes place and the
      process possibly recurses; otherwise the packet is dropped.
     </li>

     <li>
      When a Track Egress extracts a packet from a Track (decapsulates the packet), the destination of the inner packet must be either this node or a direct neighbor, or a Target of another Segment of the same Track for which this node is Ingress, otherwise the packet MUST be dropped.

      </li>

    </ul>



   <t>
    In case of a failure forwarding a packet along a Segment, e.g., the next hop
    is unreachable, the node that discovers the fault MUST send an ICMPv6 Error
    message <xref target='RFC4443'/> to the Root, with a new Code
    "Error in P-Route" (See <xref target='ICMPv6ErrPRoute'/>).
    The Root can then repair by updating the broken Segment and/or Tracks, and
    in the case of a broken Segment, remove the leftover sections of the segment
    using SM-VIOs with a lifetime of 0 indicating the section ot one or more
    nodes being removed (See <xref target='maintain'/>).
    </t>

    <t>In case of a permanent forwarding error along a Source Route path, the
    node that fails to forward SHOULD send an ICMP error with a code "Error
    in Source Routing Header" back to the source of the packet, as described
    in section 11.2.2.3. of <xref target='RFC6550'/>. Upon this message, the
    encapsulating node SHOULD stop using the source route path for a
    reasonable period of time which duration depends on the deployment, and
    it SHOULD send an ICMP message with a Code "Error in P-Route" to the
    Root. Failure to follow these steps may result
    in packet loss and wasted resources along the source route path that
    is broken.
    </t>
    <t>
    Either way, the ICMP message MUST be throttled in case of consecutive
    occurrences. It MUST be sourced at the ULA or a GUA that is used in this
    Track for the source node, so the Root can establish where the error
    happened.

      </t>
      <t>

    The portion of the invoking packet that is sent back in the ICMP message
    SHOULD record at least up to the RH if one is present, and this hop of the
    RH SHOULD be consumed by this node so that the destination in
    the IPv6 header is the next hop that this node could not reach.
    if a 6LoWPAN Routing Header (6LoRH) <xref target='RFC8138'/> is used to
    carry the IPv6 routing information in the outer header then that whole
    6LoRH information SHOULD be present in the ICMP message.
       </t>

    </section><!-- Encapsulating and Forwarding along a Track -->



<section anchor='encompression'><name>Compression of the RPL Artifacts</name>

<t>
   When using <xref target='RFC8138'/> in the Main DODAG operated in Non-Storing
   Mode in a 6LoWPAN LLN, a typical packet that circulates in the Main DODAG is
   formatted as shown in <xref target='inner'/>, representing the case where
   :
</t>

<figure anchor='inner'><name>A Packet as Forwarded along the Main DODAG</name>
              <artwork align="center">
+-+ ... -+- ... -+- ... -+-+- ... +-+-+-+ ... +-+-+ ... -+ ... +-...
|11110001|  SRH- | RPI-  | IP-in-IP | NH=1      |11110CPP| UDP | UDP
| Page 1 | 6LoRH | 6LoRH |  6LoRH   |LOWPAN_IPHC| UDP    | hdr |Payld
+-+ ... -+- ... -+- ... -+-+- ... +-+-+-+ ... +-+-+ ... -+ ... +-...
                                     &lt;=        RFC 6282      =&gt;
          &lt;================ Inner packet ==================== = =
</artwork>
</figure>
<t>
   Since there is no page switch between the encapsulated packet and the
   encapsulation, the first octet of the compressed packet that acts as page
   selector is actually removed at encapsulation, so the inner packet used in
   the descriptions below start with the SRH-6LoRH, and is verbatim the packet
   represented in <xref target='inner'/> from the second octet on.
</t>

<t>When encapsulating that inner packet to place it in the Track, the first
   header that the Ingress appends at the head of the inner packet is an
   IP-in-IP 6LoRH Header; in that header, the encapsulator address, which maps to the IPv6 source address in the uncompressed form, contains a GUA or ULA IPv6 address of the Ingress node that serves as DODAG ID for the Track, expressed in the compressed form and using the DODAGID of the Main DODAG as compression reference. If the address is compressed to 2 bytes, the resulting value for the Length field shown in <xref target='ipinip'/> is 3, meaning that the SRH-6LoRH as a whole is 5-octets long.
</t>
<figure anchor='ipinip'><name>The IP-in-IP 6LoRH Header</name>
              <artwork align="center">
 0                   1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-     ...     -+
|1|0|1| Length  | 6LoRH Type 6  |  Hop Limit    | Track DODAGID |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-     ...     -+
</artwork>
</figure>

<t> At the head of the resulting sequence of bytes, the track Ingress then adds
   the RPI that carries the TrackID as RPLinstanceID as a P-RPI-6LoRH Header, as illustrated in <xref target='PRpifmt'/>, using the TrackID as
   RPLInstanceID.
   Combined with the IP-in-IP 6LoRH Header, this allows to identify the Track without ambiguity.
</t>
<t> The SRH-6LoRH is then added at the head of the resulting sequence of bytes
   as a verbatim copy of the content of the SR-VIO that signaled the selected
   Track Leg.
</t>
<figure anchor='srh6lorh'><name>The SRH 6LoRH Header</name>
              <artwork align="center">
 0                   1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  ..         ..        ..
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    -+-    -+ ... +-    -+
|1|0|0|  Size   |6LoRH Type 0..4| Hop1 | Hop2 |     | HopN |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    -+-    -+ ... +-    -+
                                          Where N = Size + 1
</artwork>
</figure>


<t>
   The format of the resulting encapsulated packet in <xref target='RFC8138'/>
   compressed form is illustrated in <xref target='respac'/>:
</t>

<figure anchor='respac'><name>A Packet as Forwarded along a Track</name>
              <artwork align="center">
+-+ ... -+-+-+- ... -+-+-+- ... -+-+-+-+-+- ... +-+-+-+-+-+-+- ...
| Page 1 |  SRH-6LoRH  | P-RPI-6LoRH | IP-in-IP 6LoRH | Inner Packet
+-+ ... -+-+-+- ... -+-+-+- ... -+-+-+-+-+- ... +-+-+-+-+-+-+- ...

 Signals :  Loose Hops :    TrackID  :  Track DODAGID :
</artwork>
</figure>
</section><!-- Compression of the RPL Artifacts -->
    </section><!-- Root Initiated Routing State -->




    <section anchor="ov"><name>Lesser Constrained Variations</name>
    <section anchor="smmd"><name>Storing Mode Main DODAG</name>

<t>This specification expects that the Main DODAG is operated in Non-Storing
   Mode. The reasons for that limitation are mostly related to LLN operations,
   power and spectrum conservation:</t>
   <ul>
   <li>In Non-Storing Mode The Root already possesses the DODAG topology, so the
   additional topological information is reduced to the siblings.
   </li>
   <li>The downwards routes are updated with unicast messages to the Root, which
   ensures that the Root can reach back to the LLN nodes after a repair faster
   than in the case of Storing Mode. Also the Root can control the use of the
   path diversity in the DODAG to reach to the LLN nodes. For both reasons,
   Non-Storing Mode provides better capabilities for the Root to maintain the
   P-Routes.
   </li>
   <li>
   When the Main DODAG is operated in Non-Storing Mode, P-Routes enable
   loose Source Routing, which is only an advantage in that mode. Storing Mode
   does not use Source Routing Headers, and does not derive the same benefits
   from this capability.
   </li>
   </ul>


<t>On the other hand, since RPL is a Layer-3 routing protocol, its applicability
   extends beyond LLNs to a generic IP network. RPL requires fewer resources
   than alternative IGPs like OSPF, ISIS, EIGRP, BABEL or RIP at the expense
   of a route stretch vs. the shortest path routes to a destination that those
   protocols compute. P-Routes add the capability to install shortest
   and/or constrained routes to special destinations such as discussed in
   section A.9.4. of the ANIMA ACP <xref target='RFC8994'/>.
</t>
<t>
   In a powered and wired network, when enough memory to store the needed
   routes is available, the RPL Storing Mode proposes a better trade-off than
   the Non-Storing, as it reduces the route stretch and lowers the load on the
   Root. In that case, the control path between the Root and the LLN nodes is
   highly available compared to LLNs, and the nodes can be reached to maintain
   the P-Routes at most times.
   </t>

<t>
   This section specifies the additions that are needed to support Projected
   Routes when the Main DODAG is operated in Storing Mode.
   As long as the RPI can be processed adequately by the dataplane, the
   changes to this specification are limited to the DAO message.
   The Track structure, routes and forwarding operations remain the same.
   Since there is no capability negotiation, the expectation is that all the nodes in the network support this specification in the same fashion, or are configured the same way through management.
   </t>
<t>
   In Storing Mode, the Root misses the Child to Parent relationship that forms
   the Main DODAG, as well as the sibling information. To provide that knowledge
   the nodes in the network MUST send additional DAO messages that are unicast
   to the Root as Non-Storing DAO messages are.
   </t>

<t>In the DAO message, the originating router advertises a set of neighbor
   nodes using Sibling Information Options (SIO)s, regardless of the relative
   position in the DODAG of the advertised node vs. this router.
   </t>

<t>The DAO message MUST be formed as follows:
   </t>
   <ul>
   <li>
   The originating router is identified by the source address of the DAO. That
   address MUST be the one that this router registers to neighbor routers
   so the Root can correlate the DAOs from those routers when they advertise
   this router as their neighbor. The DAO contains one or more sequences of one
   Transit Information Option and one or more Sibling Information Options.
   There is no RPL Target Option so the Root is not confused into adding a
   Storing Mode route to the Target.
   </li>
   <li>
   The TIO is formed as in Storing Mode, and the Parent Address is not present.
   The Path Sequence and Path Lifetime fields
   are aligned with the values used in the Address Registration of the node(s) advertised in the SIO, as explained in Section 9.1. of
   <xref target='RFC9010'/>.
   Having similar values in all  nodes allows to factorise the TIO for multiple
   SIOs as done with <xref target='RFC6550'/>.
   </li>
   <!--
   <li>
   The TIO is followed by one RPL Target Option that signals the router that
   sends the information.  The Target Prefix in the RTO contains the address in
   full and the "Advertiser address in Full" (F) <xref target='RFC9010'/> flag
   is set to 1.
   </li>
   -->
   <li>The TIO is followed by one or more SIOs that provide an address (ULA or GUA) of the advertised neighbor node.
   </li>
   </ul>

<t>
   But the RPL routing information headers may not be supported on all type of
   routed network infrastructures, especially not in high-speed routers.
   When the RPI is not supported in the dataplane, there cannot be local RPL
   Instances and RPL can only operate as a single topology (the Main DODAG).
   The RPL Instance is that of the Main DODAG and the Ingress node that encapsulates is not the Root.
   The routes along the Tracks are alternate routes to those available along
   the Main DODAG. They MAY conflict with routes to children and MUST take
   precedence in the routing table. The Targets MUST be adjacent
   to the Track Egress to avoid loops that may form if the packet is reinjected
   in the Main DODAG.
  </t>
</section><!-- Storing Mode Main DODAG -->

    <section anchor="bfd"><name>A Track as a Full DODAG</name>

    <t>This specification builds parallel or crossing Track Legs as opposed
   to a more complex DODAG with interconnections at any place desirable. The
   reason for that limitation is related to constrained node operations, and
   capability to store large amount of topological information and compute
   complex paths:</t>
   <ul>
   <li>With this specification, the node in the LLN has no topological
   awareness, and does not need to maintain dynamic information about the link
   quality and availability.
   </li>
   <li>The Root has a complete topological information and statistical metrics
   that allow it or its PCE to perform a global optimization of all Tracks in
   its DODAG. Based on that information, the Root computes the Track Leg and  predigest the source route paths.
   </li>
   <li>
   The node merely selects one of the proposed paths and applies the associated
   pre-computed routing header in the encapsulation. This alleviates both the
   complexity of computing a path and the compressed form of the routing header.
   </li>
   </ul>
   <t>The <xref target='I-D.ietf-raw-architecture'>RAW Architecture</xref>
   actually expects the PSE at
   the Track Ingress to react to changes in the forwarding conditions along the
   Track, and reroute packets to maintain the required degree of reliability.
   To achieve this, the PSE need the full richness of a DODAG to form any path
   that could make meet the Service Level Objective (SLO).
   </t>
<t>
   This section specifies the additions that are needed to turn the Track
   into a full DODAG and enable the main Root to provide the necessary
   topological information to the Track Ingress. The expectation is that the
   metrics that the PSE uses are of an order other than that of the PCE,
   because of the difference of time scale between routing and forwarding, mor
   e in <xref target='I-D.ietf-raw-architecture'/>. It follows that the PSE
   will learn the metrics it needs from an alternate source, e.g., OAM frames.
   </t>
<t>
   To pass the topological information to the Ingress, the Root uses a P-DAO
   messages that contains sequences of Target and Transit Information options
   that collectively represent the Track, expressed in the same fashion as in
   classical Non-Storing Mode. The difference as that the Root is the source as opposed to the destination, and can report information on many Targets, possibly the full Track, with one P-DAO.

   </t>
<t>Note that the Path Sequence and Lifetime in the TIO are selected by the Root,
   and that the Target/Transit information tupples in the P-DAO are not those
   received by the Root in the DAO messages about the said Targets. The Track
   may follow sibling routes and does not need to be congruent with the Main DODAG.
   </t>
    </section><!-- A Track as a Full DODAG -->


    </section><!-- Least Constrained Variations -->

    <section anchor='prof'><name>Profiles</name>
    <t>
    This document provides a set of tools that may or may not be needed by
    an implementation depending on the type of application it serves.
    This sections described profiles that can be implemented separately and
    can be used to discriminate what an implementation can and cannot do.
    This section describes profiles that enable to implement only a portion
    of this specification to meet a particular use case.
    </t><t>
    Profiles 0 to 2 operate in the Main RPL Instance and do not require the
    support of local RPL Instances or the indication of the RPL Instance in the
    data plane. Profile 3 and above leverage Local RPL Instances to build
    arbitrary Tracks Rooted at the Track Ingress and using its namespace for
    TrackID.
    </t><t>
    Profiles 0 and 1 are REQUIRED by all implementations that may be used in
    LLNs; Profiles 1 leverages Storing Mode to reduce the size of the Source
    Route Header in the most common LLN deployments. Profile 2 is RECOMMENDED
    in high speed / wired environment to enable traffic Engineering and
    network automation. All the other profile / environment combinations are
    OPTIONAL.
    </t>

    <dl>
    <dt> Profile 0 </dt><dd>
      Profile 0 is the Legacy support of <xref target='RFC6550'/> Non-Storing
      Mode, with default routing Northwards (up) and strict source routing
      Southwards (down the main DOAG). It provides the minimal common
      functionality that must be
      implemented as a prerequisite to all the Track-supporting profiles.
      The other Profiles extend Profile 0 with selected capabilities that this
      specification introduces on top.
    </dd>
    <dt> Profile 1 (Storing Mode P-Route Segments along the Main DODAG) </dt><dd>
      Profile 1 does not create new paths; compared to Profile 0, it combines
      Storing and Non-Storing Modes to balance the size of the Routing Header
      in the packet and the amount of state in the intermediate routers in a
      Non-Storing Mode RPL DODAG.
    </dd>
    <dt> Profile 2 (Non-Storing Mode P-Route Segments along the Main DODAG)</dt><dd>
      Profile 2 extends Profile 0 with Strict Source-Routing Non-Storing Mode
      P-Routes along the Main DODAG, which is the same as Profile 1 but using
      NSM VIOs as opposed to SM VIOs. Profile 2 provides the same capability to
      compress the SRH in packets down the Main DODAG as Profile 1, but it
      require an encapsulation, in order to insert an additional SRH between
      the loose source routing hops.
      In that case, the Tracks MUST be installed as subTracks of the Main DODAG,
      the main RPL Instance MUST be used as TrackID, and the Ingress node that
      encapsulates is not the Root as it does not own the DODAGID.
    </dd>
    <dt> Profile 3 </dt><dd>
       In order to
      form the best path possible, those Profiles require the support of
      Sibling Information Option to inform the Root of additional possible hops.
      Profile 3 extends Profile 1 with additional Storing Mode P-Routes
      that install segments that do not follow the Main DODAG.
      If the Segment Ingress (in the SM-VIO) is the same as the IPv6 Address of
      the Track Ingress (in the projected DAO base Object), the P-DAO creates an
      implicit Track between the Segment Ingress and the Segment Egress.
      </dd>
    <dt> Profile 4 </dt><dd>
      Profile 4 extends Profile 2 with Strict Source-Routing Non-Storing Mode
      P-Routes to form East-West Tracks that are inside the Main DODAG but do
      not necessarily follow it. A Track is formed as one or more strict source
      source routed paths between the Root that is the Track Ingress, and the
      Track Egress that is the last node.
    </dd>
    <dt> Profile 5 </dt><dd>
      Profile 5 Combines Profile 4 with Profile 1 and enables to loose source
      routing between the Ingress and the Egress of the Track. As in Profile 1,
      Storing Mode P-Routes connect the dots in the loose source route.
    </dd>
    <dt> Profile 6 </dt><dd>
      Profile 6 Combines Profile 4 with Profile 2 and also enables to loose
      source routing between the Ingress and the Egress of the Track.

    </dd>
    <dt> Profile 7 </dt><dd>
      Profile 7 implements profile 5 in a Main DODAG that is operated in
      Storing Mode as presented in <xref target='smmd'/>. As in Profile 1 and 2,
      the TrackID is the RPLInstanceID of the Main DODAG. Longest match rules
      decide whether a packet is sent along the Main DODAG or rerouted in a
      track.
    </dd>
    <dt> Profile 8 </dt><dd>
      Profile 8 is offered in preparation of the RAW work, and for use cases
      where an arbitrary node in the network can afford the same code
      complexity as the RPL Root in a traditional deployment. It offers a full
      DODAG visibility to the Track Ingress as specified in <xref target='bfd'/>
      in a Non-Storing Mode Main DODAG.
    </dd>
    <dt> Profile 9 </dt><dd>
      Profile 9 combines profiles 7 and 8, operating the Track as a full DODAG
      within a Storing Mode Main DODAG, using only the Main DODAG RPLInstanceID
      as TrackID.
    </dd>
    </dl>


    </section><!-- Profiles -->

    <section anchor='back'><name>Backwards Compatibility</name>

    <t>
    This specification can operate in a mixed network where some nodes support
    it and some do not. There are restructions, though. All nodes that need to
    process a P-DAO MUST support this specification.
    As discussed in <xref target='mtsch'/>, how the root knows whether the
    nodes capabilities and whether it support this specification is out of scope.
    </t>
    <t>
    This specification defines the 'D' flag in the  RPL DODAG Configuration
    Option (see <xref target='dflag'/>) to signal that the RPL nodes can request
    the creation of Tracks. The requester may not know whether the Track can
    effectively be constructed, and whether enough nodes along the preferred
    paths support this specification. Therefore it makes sense to only set the
    'D' flags in DIO when the conditions of success are in place, in particular
    when all the nodes that could be on path of tracks are upgraded.
    </t>
    </section><!-- Backwards Compatibility -->
    <section><name>Security Considerations</name>


     <t>
   It is worth noting that with <xref target='RFC6550'/>, every
   node in the LLN is RPL-aware and can inject any RPL-based attack in the
   network. This draft uses messages that are already present in RPL
   <xref target='RFC6550'/> with optional secured versions. The same secured
   versions may be used with this draft, and whatever security is deployed for
     a given network also applies to the flows in this draft.

 </t>
 <t>
	The LLN nodes depend on the 6LBR and the RPL participants for their
    operation.
	A trust model is necessary to ensure that the right devices are
	acting in these roles, so as to avoid threats such as black-holing,
    (see <xref target='RFC7416'/> section 7). This trust model could be
    at a minimum based on a Layer-2 Secure joining and the Link-Layer security.
    This is a generic 6LoWPAN requirement, see Req5.1 in Appendix B.5 of <xref target='RFC8505'/>.
 </t><t>
    In a general manner, the Security Considerations in <xref target='RFC6550'/>,
    and <xref target='RFC7416'/> apply to this specification as well.
    The Link-Layer security is needed in particular to prevent
    Denial-Of-Service attacks whereby a rogue router creates a high churn in the
    RPL network by constantly injected forged P-DAO messages and using up all
    the available storage in the attacked routers.

 </t><t>
   With this specification, only the Root may generate P-DAO messages. PDR
   messages may only be sent to the Root. This specification expects that the
   communication with the Root is authenticated but does enforce which method
   is used.
</t><t>
    Additionally, the trust model could include a role validation (e.g., using a
    role-based authorization) to ensure that the node that
    claims to be a RPL Root is entitled to do so. That trust should propagate
    from Egress to Ingress in the case of a Storing Mode P-DAO.

	</t><t>
    This specification suggests some validation of the VIO to prevent basic
    loops by avoiding that a node appears twice. But that is only a minimal
    protection. Arguably, an attacker that can inject P-DAOs can reroute any
    traffic and deplete critical resources such as spectrum and battery in
    the LLN rapidly.
	</t>


</section>
<section anchor='IANAcon'><name>IANA Considerations</name>




   <section anchor="iana-d"><name>RPL DODAG Configuration Option Flag</name>
    <t>
    IANA is requested to assign a flag from the "DODAG Configuration Option
    Flags for MOP 0..6" <xref target='RFC9010'/> registry as follows:
    </t>

   <table  anchor="nexndopt"><name>New DODAG Configuration Option Flag</name>
   <thead>
      <tr><td>Bit Number</td><td>Capability Description</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>0 (suggested)</td><td>Projected Routes Support (D)</td><td>THIS RFC</td></tr>
   </tbody>
   </table>

<t>IANA is requested to add [THIS RFC] as a reference for MOP 7 in the RPL Mode of Operation registry.
</t>
</section><!-- RPL DODAG Configuration Option Flag -->
   <section anchor='elec6lorh'><name>Elective 6LoWPAN Routing Header Type</name>

   <t>  This document updates the IANA registry titled "Elective 6LoWPAN
   Routing Header Type" that was created for <xref target='RFC8138'/>  and assigns the following value:
</t>
        <table anchor="elec6lorhtbl"><name>New Elective 6LoWPAN Routing Header Type</name>
   <thead>

          <tr><th align='center'>Value</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>8 (Suggested)</td>

          <td align='left'>P-RPI-6LoRH</td>

          <td align='left'>This document</td></tr>

    </tbody>
        </table>
   </section><!-- Elective 6LoWPAN Routing Header Type -->


   <section anchor='crit6lorh'><name>Critical 6LoWPAN Routing Header Type</name>
   <t>  This document updates the IANA registry titled "Critical 6LoWPAN
   Routing Header Type" that was created for <xref target='RFC8138'/>  and assigns the following value:
</t>
        <table anchor="crit6lorhtbl"><name>New Critical 6LoWPAN Routing Header Type</name>
   <thead>

          <tr><th align='center'>Value</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>8 (Suggested)</td>

          <td align='left'>P-RPI-6LoRH</td>

          <td align='left'>This document</td></tr>

    </tbody>
        </table>
   </section><!-- Critical 6LoWPAN Routing Header Type -->




   <section anchor='RPIIANA'><name>Subregistry For The RPL Option Flags</name>
    <t>
   IANA is required to create a subregistry for the 8-bit RPL Option Flags field, as detailed in <xref target='Rpifmt'/>, under the "Routing Protocol for Low Power and Lossy Networks (RPL)" registry. The bits are indexed from 0 (leftmost) to 7. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Indication When Set</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>. The initial allocation is as indicated in <xref target='RPLPDRflagRegtbl'/>:
 </t>

        <table anchor="RPLoptFlagtbl"><name>Initial PDR Flags</name>
   <thead>

          <tr><th align='center'>Bit number</th>

          <th align='left'>Indication When Set</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0</td>

          <td align='left'>Down 'O'</td>

          <td align='left'><xref target='RFC6553'/> </td></tr>

          <tr><td align='center'>1</td>

          <td align='left'>Rank-Error (R)</td>

          <td align='left'><xref target='RFC6553'/> </td></tr>

          <tr><td align='center'>2</td>

          <td align='left'>Forwarding-Error (F)</td>

          <td align='left'><xref target='RFC6553'/> </td></tr>

          <tr><td align='center'>3 (Suggested)</td>

          <td align='left'>Projected-Route (P)</td>

          <td align='left'>This document</td></tr>
    </tbody>
        </table>
   </section><!-- Subregistry For The RPL Option Flags -->

   <section anchor='RPLCtrlMsgReg'><name>RPL Control Codes</name>

    <t>This document extends the IANA Subregistry created by RFC 6550 for RPL
    Control Codes as indicated in <xref target="ianaRPLCtrlMsgtbl"/>:</t>


        <table anchor="ianaRPLCtrlMsgtbl"><name>New RPL Control Codes</name>
   <thead>
          <tr><th align='center'>Code</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0x09 (Suggested)</td>

          <td align='left'>Projected DAO Request (PDR)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>0x0A (Suggested)</td>

          <td align='left'>PDR-ACK</td>

          <td align='left'>This document</td></tr>
   </tbody>
        </table>


   </section> <!-- "RPL Control Codes" -->

   <section anchor='RPLCtrlMsgOptionsReg'><name>RPL Control Message Options</name>

    <t>This document extends the IANA Subregistry created by RFC 6550 for
    RPL Control Message Options as indicated in <xref target="ianaRPLCtrlMsgopttbl"/>:</t>



        <table anchor="ianaRPLCtrlMsgopttbl"><name>RPL Control Message Options</name>
   <thead>
          <tr><th align='center'>Value</th>

          <th align='left'>Meaning</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0x0E (Suggested)</td>

          <td align='left'>Stateful VIO (SM-VIO)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>0x0F (Suggested)</td>

          <td align='left'>Source-Routed VIO (NSM-VIO)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>0x10 (Suggested)</td>

          <td align='left'>Sibling Information option</td>

          <td align='left'>This document</td></tr>
   </tbody>
        </table>

   </section> <!-- "RPL Control Message Options" -->




   <section anchor='RPLPDRflagReg'>
   <name>SubRegistry for the Projected DAO Request Flags</name>

   <t>
   IANA is required to create a registry for the 8-bit Projected DAO Request
   (PDR) Flags field. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>. The initial allocation is as indicated in <xref target='RPLPDRflagRegtbl'/>:
 </t>

        <table anchor="RPLPDRflagRegtbl"><name>Initial PDR Flags</name>
   <thead>

          <tr><th align='center'>Bit number</th>

          <th align='left'>Capability description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0</td>

          <td align='left'>PDR-ACK request (K)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>1</td>

          <td align='left'>Requested path should be redundant (R)</td>

          <td align='left'>This document</td></tr>
    </tbody>
        </table>

   </section> <!-- SubRegistry for the Projected DAO Request Flags -->


   <section anchor='RPLPDRackflagReg'>
   <name>SubRegistry for the PDR-ACK Flags</name>

   <t>
   IANA is required to create an subregistry for the 8-bit PDR-ACK Flags field.
   Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t>Registration procedure is "Standards Action" <xref target='RFC8126'/>.
    No bit is currently defined for the PDR-ACK Flags.
   </t>

   </section> <!-- SubRegistry for the PDR-ACK Flags -->



<section anchor='iana-stats-nonrej'>
<name>Subregistry for the PDR-ACK Acceptance Status Values </name>
 <t>
	IANA is requested to create a Subregistry for the PDR-ACK Acceptance
    Status values.
</t>
<ul spacing='normal'>
  <li> Possible values are 6-bit unsigned integers (0..63).</li>
  <li> Registration procedure is "Standards Action" <xref target='RFC8126'/>.</li>
  <li> Initial allocation is as indicated in <xref target='iana-ack-status'/>:</li>
</ul>




   <table anchor='iana-ack-status'><name>Acceptance values of the PDR-ACK Status</name>
   <thead>
      <tr><td>Value</td><td>Meaning</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>0</td><td>Unqualified Acceptance</td><td>This document</td></tr>
   </tbody>

   </table>


</section><!-- Subregistry for the PDR-ACK Acceptance Status Values -->


<section anchor='iana-stats-rej'>
<name>Subregistry for the PDR-ACK Rejection Status Values</name>
 <t>
	IANA is requested to create a Subregistry for the PDR-ACK Rejection
    Status values.
</t>
<ul spacing='normal'>
  <li> Possible values are 6-bit unsigned integers (0..63).</li>
  <li> Registration procedure is "Standards Action" <xref target='RFC8126'/>.</li>
  <li> Initial allocation is as indicated in <xref target='iana-nack-status'/>:</li>
</ul>


   <table anchor='iana-nack-status'><name>Rejection values of the PDR-ACK Status</name>
   <thead>
      <tr><td>Value</td><td>Meaning</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>0</td><td>Unqualified Rejection</td><td>This document</td></tr>
      <tr><td>1</td><td>Transient Failure</td><td>This document</td></tr>
   </tbody>

   </table>

</section><!-- Subregistry for the PDR-ACK Rejection Status Values -->



   <section anchor='RPLVIOflagReg'>
   <name>SubRegistry for the Via Information Options Flags</name>

   <t>
   IANA is requested to create a Subregistry for the 5-bit Via Information Options
   (Via Information Option) Flags field. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>.
   No bit is currently defined for the Via Information Options (Via Information Option) Flags.
   </t>

   </section> <!-- SubRegistry for the Via Information Options Flags -->


   <section anchor='RPLSIOflagReg'>
   <name>SubRegistry for the Sibling Information Option Flags</name>

   <t>
   IANA is required to create a registry for the 5-bit Sibling Information
   Option (SIO) Flags field. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>. The initial allocation is as indicated in <xref target='RPLSIORegtbl'/>:
 </t>

        <table anchor="RPLSIORegtbl"><name>Initial SIO Flags</name>
   <thead>

          <tr><th align='center'>Bit number</th>

          <th align='left'>Capability description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0 (Suggested)</td>

          <td align='left'>"S" flag: Sibling in same DODAG as Self</td>

          <td align='left'>This document</td></tr>

    </tbody>
        </table>

   </section> <!-- SubRegistry for the Sibling Information Option Flags -->




<section anchor="iana-P-DAO"><name>Destination Advertisement Object Flag</name>


<t>
   This document modifies the "Destination Advertisement Object (DAO) Flags"
   registry initially
   created in Section 20.11 of <xref target='RFC6550'/> .
</t><t>
  <xref target='extP-DAO'/> also defines one new entry in the Registry as follows:
    </t>

   <table  anchor="iana-P-DAOtbl">
      <name>New Destination Advertisement Object (DAO) Flag</name>
   <thead>
      <tr><td>Bit Number</td><td>Capability Description</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>2 (Suggested)</td><td>Projected DAO (P)</td><td>THIS RFC</td></tr>
   </tbody>
   </table>

   </section>

<section anchor="iana-P-DAO-aCK"><name>Destination Advertisement Object Acknowledgment Flag</name>


<t>
   This document modifies the "Destination Advertisement Object (DAO) Acknowledgment Flags"
   registry initially
   created in Section 20.12 of <xref target='RFC6550'/> .
</t><t>
  <xref target='extP-DAO-ACK'/> also defines one new entry in the Registry as follows:
    </t>

   <table  anchor="iana-P-DAO-ACKtbl">
      <name>New Destination Advertisement Object Acknowledgment Flag</name>
   <thead>
      <tr><td>Bit Number</td><td>Capability Description</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>1 (Suggested)</td><td>Projected DAO-ACK (P)</td><td>THIS RFC</td></tr>
   </tbody>
   </table>

   </section>



   <section anchor='ICMPv6ErrPRoute'>
        <name>New ICMPv6 Error Code</name>
        <t>In some cases RPL will return an ICMPv6 error message when a
        message cannot be forwarded along a P-Route.</t>

        <t>IANA has defined an ICMPv6 "Code" Fields Registry for ICMPv6
        Message Types. ICMPv6 Message Type 1 describes "destination Unreachable"
        codes. This specification requires that a new code is allocated from the
        ICMPv6 Code Fields Registry for ICMPv6 Message Type 1, for "Error in
        P-Route", with a suggested code value of 8, to be confirmed by
        IANA.</t>
   </section> <!--"ICMPv6: Error in a P-Route" -->



<section anchor='iana-stats-rpl-rej'><name>RPL Rejection Status values </name>
 <t>
	This specification updates the Subregistry for the "RPL Rejection Status"
    values under the RPL registry, as follows:
</t>

   <table anchor='iana-nack-Status'><name>Rejection values of the RPL Status </name>
   <thead>
      <tr><td>Value</td><td>Meaning</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>2 (Suggested)</td><td>Out of Resources</td><td>THIS RFC</td></tr>
      <tr><td>3 (Suggested)</td><td>Error in VIO</td><td>THIS RFC</td></tr>
      <tr><td>4 (Suggested)</td><td>Predecessor Unreachable</td><td>THIS RFC
      </td></tr>
      <tr><td>5 (Suggested)</td><td>Unreachable Target</td><td>THIS RFC
      </td></tr>
      <tr><td>6..63</td><td>Unassigned</td><td></td></tr>
   </tbody>

   </table>

</section> <!-- Subregistry for RPL Rejection Status values -->


</section> <!-- "IANA Considerations"-->


<section><name>Acknowledgments</name>
<t>The authors wish to acknowledge JP Vasseur, Remy Liubing, James Pylakutty,
   and Patrick Wetterwald for their contributions to the ideas developed here.
   Many thanks to Dominique Barthel and SVR Anand for their global contribution
   to 6TiSCH, RAW and this document, as well as text suggestions that were
   incorporated, and to Michael Richardson for his useful recommendations based
   on his global view of the system all along the developement of this
   specification.
   Also special thanks Toerless Eckert for his deep review, with many excellent
   suggestions that improved the readability and well as the content of the
   specification.
   Many thanks to Remous-Aris Koutsiamanis for his review during WGLC.
  </t>
</section>

    </middle>
    <back>

   <displayreference   target="RFC1122"    to="INT-ARCHI"/>
   <displayreference   target="RFC4944"        to="6LoWPAN"/>
   <displayreference   target="RFC6550"        to="RPL"/>
   <displayreference   target="I-D.ietf-raw-architecture"   to="RAW-ARCHI"/>
   <displayreference   target="I-D.ietf-raw-use-cases"   to="USE-CASES"/>

    <references><name>Normative References</name>

	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4655.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6282.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6550.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6553.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6554.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8138.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8754.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9008.xml'/>

    </references><references><name>Informative References</name>

	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5440.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6997.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7102.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7416.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8025.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8402.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8505.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8655.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8930.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8931.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8994.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9010.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9030.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9035.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-raw-architecture.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-raw-use-cases.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.kuehlewind-update-tag.xml'/>


     <xi:include href="http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.irtf-panrg-path-properties.xml"/>
      <reference anchor='PCE' target='https://dataTracker.ietf.org/doc/charter-ietf-pce/'>
         <front>
            <title>Path Computation Element</title>
            <author>
               <organization>IETF</organization>
            </author>
            <date/>
         </front>
      </reference>

    </references>

    </back>




</rfc>
